let request,db;self.addEventListener("unhandledrejection",event=>{const reason=event?.reason;console.error(reason);let error=reason?.stack||reason?.message;if(typeof error!=="string"||!error){error="Something went wrong"}self.postMessage({error:error})});self.onmessage=async({data})=>{if(!db){await IDBInit()}self.postMessage({status:"Exporting User Data"});if(data==="android"){self.postMessage({state:0})}const importantData=await getIDBDataAsBlob(["username","categories","excludedMediaIds","mediaEntriesInfo","mediaEntries"]);if(!(importantData.categories instanceof Blob)||!(importantData.excludedMediaIds instanceof Blob)||!(importantData.mediaEntriesInfo instanceof Blob)||!(importantData.mediaEntries instanceof Blob)){self.postMessage({missingData:true});return}let backUpData=Object.assign(importantData,await getIDBDataAsBlob(["mediaUpdateAt","hiddenMediaEntries","algorithmFilters","mediaCautions","userMediaEntries","userMediaUpdateAt","tagInfo","tagInfoUpdateAt"]));for(const key in backUpData){if(!(backUpData[key]instanceof Blob)){delete backUpData[key]}}self.postMessage({progress:0});backUpData=await compressBlobs(backUpData);if(data==="android"){backUpData=await compressBlobToBuffer(backUpData);backUpData=arrayBufferToBase64(backUpData);backUpData=(new TextEncoder).encode(backUpData).buffer;const CHUNK_SIZE=64*1024,DELAY=300,TOTAL_LENGTH=backUpData.byteLength;let offset=0;while(true){const chunk=new Uint8Array(backUpData.slice(offset,offset+CHUNK_SIZE));self.postMessage({state:1,chunk:chunk,loaded:Math.min(100,offset/TOTAL_LENGTH*100)},[chunk.buffer]);offset+=CHUNK_SIZE;if(offset>TOTAL_LENGTH)break;await new Promise(resolve=>setTimeout(resolve,DELAY))}await setIDBData("runnedAutoExportAt",Date.now());self.postMessage({state:2,username:importantData.username instanceof Blob?await decompressBlobToJSON(importantData.username):null})}else{self.postMessage({progress:30});backUpData=await compressBlob(backUpData);const url=URL.createObjectURL(backUpData);await setIDBData("runnedAutoExportAt",(new Date).getTime());self.postMessage({status:"Data has been Exported"});self.postMessage({progress:100});self.postMessage({status:null});self.postMessage({url:url,username:importantData.username instanceof Blob?await decompressBlobToJSON(importantData.username):null})}};function isJsonObject(obj){return Object.prototype.toString.call(obj)==="[object Object]"}function IDBInit(){return new Promise((resolve,reject)=>{try{const request=indexedDB.open("Kanshi.Media.Recommendations.AniList.W~uPtWCq=vG$TR:Zl^#t<vdS]I~N70",1);request.onsuccess=({target})=>{db=target.result;resolve()};request.onupgradeneeded=({target})=>{try{const{result,transaction}=target;const stores=["mediaEntries","mediaEntriesInfo","excludedMediaIds","mediaUpdateAt","mediaOptions","orderedMediaOptions","tagInfo","tagInfoUpdateAt","username","userMediaEntries","userMediaUpdateAt","recommendedMediaEntries","algorithmFilters","mediaCautions","hiddenMediaEntries","categories","selectedCategory","autoPlay","gridFullView","showRateLimit","showStatus","autoUpdate","autoExport","runnedAutoUpdateAt","runnedAutoExportAt","exportPathIsAvailable","shouldManageMedia","shouldProcessRecommendedEntries","nearestMediaReleaseAiringAt","recommendationError","visited","others"];for(const store of stores){result.createObjectStore(store)}transaction.oncomplete=()=>{db=result;resolve()}}catch(ex){console.error(ex);reject(ex);transaction.abort()}};request.onerror=ex=>{console.error(ex);reject(ex)}}catch(ex){console.error(ex);reject(ex)}})}function setIDBData(key,value){return new Promise((resolve,reject)=>{try{const transaction=db.transaction(key,"readwrite");const put=transaction.objectStore(key).put(value,key);put.onerror=ex=>{console.error(ex);reject(ex);transaction.abort()};transaction.oncomplete=()=>resolve()}catch(ex){console.error(ex);reject(ex)}})}function getIDBDataAsBlob(recordKeys){return new Promise(async(resolve,reject)=>{try{const transaction=db.transaction(recordKeys,"readonly");resolve(Object.fromEntries(await Promise.all(recordKeys.map(key=>{return new Promise(resolve=>{const get=transaction.objectStore(key).get(key);get.onsuccess=async()=>{let value=get.result;if(value instanceof Blob){resolve([key,value])}else if(value!=null){value=await compressBlob(new Blob([JSON.stringify(value)]));resolve([key,value])}else{resolve([key])}};get.onerror=ex=>{console.error(ex);resolve([key])}})}))))}catch(ex){console.error(ex);reject(ex)}})}async function compressBlobs(blobsWithKeys){const blobsArray=[];let totalSize=4;for(const[key,blob]of Object.entries(blobsWithKeys)){const keyBlob=new Blob([key]);blobsArray.push({keyBlob:keyBlob,blob:blob});totalSize+=4+keyBlob.size+4+blob.size}const combinedArrayBuffer=new ArrayBuffer(totalSize);const dataView=new DataView(combinedArrayBuffer);dataView.setUint32(0,Object.keys(blobsWithKeys).length,true);let offset=4;for(const{keyBlob,blob}of blobsArray){const keyBuffer=await keyBlob.arrayBuffer();const blobBuffer=await blob.arrayBuffer();dataView.setUint32(offset,keyBlob.size,true);offset+=4;new Uint8Array(combinedArrayBuffer).set(new Uint8Array(keyBuffer),offset);offset+=keyBlob.size;dataView.setUint32(offset,blob.size,true);offset+=4;new Uint8Array(combinedArrayBuffer).set(new Uint8Array(blobBuffer),offset);offset+=blob.size}return new Blob([combinedArrayBuffer])}async function compressBlob(blob){return await new Response(blob.stream().pipeThrough(new CompressionStream("gzip"))).blob()}async function compressBlobToBuffer(blob){return new Uint8Array(await new Response(blob.stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer())}async function decompressBlobToJSON(blob){return await new Response(blob.stream().pipeThrough(new DecompressionStream("gzip"))).json()}function arrayBufferToBase64(data){let binary="";data=new Uint8Array(data);for(let i=0;i<data.byteLength;i++){binary+=String.fromCharCode(data[i])}return btoa(binary)}
let db,server,connected;self.addEventListener("unhandledrejection",event=>{const reason=event?.reason;console.error(reason);let error=reason?.stack||reason?.message;if(typeof error!=="string"||!error){error="Something went wrong"}self.postMessage({error:error})});self.onmessage=async({data})=>{if(!db)await IDBInit();const recommendedMediaEntriesArray=Object.values(await getIDBData("recommendedMediaEntries")||{}),currentDateAt=Math.floor((new Date).getTime()/1e3),dayInMillis=1e3*60*60*24,isAndroid=data==="android",mediaReleaseNotifications=[];let nearestMediaReleaseAiringAt;for(let i=0;i<recommendedMediaEntriesArray.length;i++){const{id,title,coverImageUrl,mediaUrl,userStatus,weightedScore,episodes,episodeProgress,nextAiringEpisode}=recommendedMediaEntriesArray[i];if(!isJsonObject(nextAiringEpisode))continue;const{episode,airingAt,estimated}=nextAiringEpisode;if(estimated)continue;const{english,romaji,native}=title||{};const releaseDateMillis=airingAt*1e3;if(isValidNumber(episode)&&isValidDateTime(releaseDateMillis)){if(new Date(releaseDateMillis)>new Date&&airingAt>currentDateAt&&(nearestMediaReleaseAiringAt>airingAt||nearestMediaReleaseAiringAt==null)){nearestMediaReleaseAiringAt=airingAt}if(isAndroid){if((userStatus!=="Unseen"||weightedScore>.01)&&releaseDateMillis>=(new Date).getTime()-dayInMillis){const $title=english||romaji||native,$imageUrl=coverImageUrl||"",$episodeProgress=episodeProgress||0;mediaReleaseNotifications.push({id:id,title:typeof $title==="string"?$title:"",releaseEpisode:episode,maxEpisode:typeof episodes==="number"?episodes:-1,releaseDateMillis:releaseDateMillis,userStatus:typeof userStatus==="string"?userStatus:"Unseen",imageUrl:typeof $imageUrl==="string"?$imageUrl:"",mediaUrl:typeof mediaUrl==="string"?mediaUrl:"",episodeProgress:typeof $episodeProgress==="number"?$episodeProgress:0})}}}}if(isAndroid){self.postMessage({nearestMediaReleaseAiringAt:nearestMediaReleaseAiringAt,mediaReleaseNotificationsBlob:await compressBlob(new Blob([JSON.stringify(mediaReleaseNotifications)]))})}else{self.postMessage({nearestMediaReleaseAiringAt:nearestMediaReleaseAiringAt})}};function IDBInit(){return new Promise((resolve,reject)=>{try{const request=indexedDB.open("Kanshi.Media.Recommendations.AniList.W~uPtWCq=vG$TR:Zl^#t<vdS]I~N70",1);request.onsuccess=({target})=>{db=target.result;resolve()};request.onupgradeneeded=({target})=>{try{const{result,transaction}=target;const stores=["mediaEntries","mediaEntriesInfo","excludedMediaIds","mediaUpdateAt","mediaOptions","orderedMediaOptions","tagInfo","tagInfoUpdateAt","username","userMediaEntries","userMediaUpdateAt","recommendedMediaEntries","algorithmFilters","mediaCautions","hiddenMediaEntries","categories","selectedCategory","autoPlay","gridFullView","showRateLimit","showStatus","autoUpdate","autoExport","runnedAutoUpdateAt","runnedAutoExportAt","exportPathIsAvailable","shouldManageMedia","shouldProcessRecommendedEntries","nearestMediaReleaseAiringAt","recommendationError","visited","others"];for(const store of stores){result.createObjectStore(store)}transaction.oncomplete=()=>{db=result;resolve()}}catch(ex){console.error(ex);reject(ex);transaction.abort()}};request.onerror=ex=>{console.error(ex);reject(ex)}}catch(ex){console.error(ex);reject(ex)}})}function getIDBData(key){return new Promise(resolve=>{try{const get=db.transaction(key,"readonly").objectStore(key).get(key);get.onsuccess=async()=>{let value=get.result;if(value instanceof Blob){value=await new Response(value.stream().pipeThrough(new DecompressionStream("gzip"))).json()}resolve(value)};get.onerror=ex=>{console.error(ex);resolve()}}catch(ex){console.error(ex);resolve()}})}async function compressBlob(blob){return await new Response(blob.stream().pipeThrough(new CompressionStream("gzip"))).blob()}function isJsonObject(obj){return Object.prototype.toString.call(obj)==="[object Object]"}function isValidNumber(num){return typeof num==="number"&&!isNaN(num)&&isFinite(num)&&num<=Number.MAX_SAFE_INTEGER}function isValidDateTime(dateTime){return typeof dateTime==="number"&&!isNaN(new Date(dateTime))}
let db;self.addEventListener("unhandledrejection",event=>{const reason=event?.reason;console.error(reason);let error=reason?.stack||reason?.message;if(typeof error!=="string"||!error){error="Something went wrong"}self.postMessage({error:error})});self.onmessage=async({data})=>{if(!db)await IDBinit();const filters=await retrieveJSON("filters");if(isJsonObject(filters)&&!jsonIsEmpty(filters)){const orderedFilters={sortFilter:["weighted score","score","average score","user score","popularity","trending","date","date updated","date added","favorites"],season:["current season","next season","previous season","ongoing seasons","future seasons","past seasons","Winter","Spring","Summer","Fall"],"flexible inclusion":["OR: genre","OR: tag","OR: studio","OR: genre / tag","OR: genre / studio","OR: tag / studio","OR: genre / tag / studio"],"shown metric":["weighted score","score","average score","user score","popularity","favorites","trending"],"shown list":["recommended studios","non-caution","non-semi-caution","recommended score","semi-recommended score","other"]};const orderedFiltersKeys=["genre","tag","tag category","year","format","country of origin","release status","user status","studio"];const optionsSort={year:"descnum",format:{Special:9,"One Shot":8,ONA:7,OVA:6,"TV Short":5,Movie:4,TV:3,Novel:2,Manga:1,Anime:0},"country of origin":{TW:3,CN:2,KR:1,JP:0}};const algorithmFilterSelections={genre:1,tag:1,"tag category":1};for(let i=0,l=orderedFiltersKeys.length;i<l;i++){const filterKey=orderedFiltersKeys[i],isAlgorithmFilterSelection=algorithmFilterSelections[filterKey];let options=Object.keys(filters[filterKey]).reduce((uniqueOptions,k)=>{if(!uniqueOptions[k]){uniqueOptions[k]=1}return uniqueOptions},{});if(isAlgorithmFilterSelection){delete options["All"];options=Object.keys(options)}else{options=Object.keys(options)}const optionSort=optionsSort[filterKey];if(optionSort==="descnum"){options.sort((a,b)=>parseFloat(b)-parseFloat(a))}else if(isJsonObject(optionSort)){options.sort((a,b)=>{const optionSortA=optionSort[a];const optionSortB=optionSort[b];const isNumberA=typeof optionSortA==="number";const isNumberB=typeof optionSortB==="number";if(isNumberA&&isNumberB){return optionSortA-optionSortB}if(isNumberA){return-1}if(isNumberB){return 1}const isStringA=typeof a==="string";const isStringB=typeof b==="string";if(isStringA&&isStringB){return a.localeCompare(b,undefined,{sensitivity:"base"})}if(isStringA){return-1}if(isStringB){return 1}return 0})}else{options.sort((a,b)=>a.localeCompare(b,undefined,{sensitivity:"base"}))}if(isAlgorithmFilterSelection){options.unshift("All")}orderedFilters[filterKey]=options}self.postMessage({orderedFilters:orderedFilters})}else{self.postMessage({error:"Filters not found."})}};function IDBinit(){return new Promise(resolve=>{let request=indexedDB.open("Kanshi.Media.Recommendations.Anilist.W~uPtWCq=vG$TR:Zl^#t<vdS]I~N70",1);request.onsuccess=event=>{db=event.target.result;resolve()};request.onupgradeneeded=event=>{db=event.target.result;db.createObjectStore("others");event.target.transaction.oncomplete=()=>{resolve()}};request.onerror=error=>{console.error(error)}})}function retrieveJSON(name){return new Promise(resolve=>{try{let get=db.transaction("others","readonly").objectStore("others").get(name);get.onsuccess=()=>{let result=get.result;if(result instanceof Blob){result=JSON.parse((new FileReaderSync).readAsText(result))}else if(result instanceof ArrayBuffer){result=JSON.parse((new TextDecoder).decode(result))}resolve(result)};get.onerror=ex=>{console.error(ex);resolve()}}catch(ex){console.error(ex);resolve()}})}function jsonIsEmpty(obj){for(const key in obj){return false}return true}function isJsonObject(obj){return Object.prototype.toString.call(obj)==="[object Object]"}
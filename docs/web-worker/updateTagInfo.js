let db,server,connected;self.addEventListener("unhandledrejection",event=>{const reason=event?.reason;console.error(reason);let error=reason?.stack||reason?.message;if(typeof error!=="string"||!error){error="Something went wrong"}self.postMessage({error:error})});self.onmessage=async({data})=>{if(data?.connected!=null){connected=data?.connected;return}if(server==null&&data?.server!=null){server=data.server}if(!db)await IDBInit();const{tagInfo,tagInfoUpdateAt}=await getIDBRecords(["tagInfo","tagInfoUpdateAt"]);if(tagInfoUpdateAt>0&&hasTagInfoData(tagInfo)){const tagInfoUpdateAtDate=new Date(tagInfoUpdateAt*1e3);const currentDate=new Date;const currentYear=currentDate.getFullYear();const seasons={Winter:new Date(parseInt(currentYear),0,1),Spring:new Date(parseInt(currentYear),3,1),Summer:new Date(parseInt(currentYear),6,1),Fall:new Date(parseInt(currentYear),9,1)};let shouldUpdateTagInfo;if(currentDate>=seasons.Winter&&currentDate<seasons.Spring){shouldUpdateTagInfo=tagInfoUpdateAtDate<seasons.Winter}else if(currentDate>=seasons.Spring&&currentDate<seasons.Summer){shouldUpdateTagInfo=tagInfoUpdateAtDate<seasons.Spring}else if(currentDate>=seasons.Summer&&currentDate<seasons.Fall){shouldUpdateTagInfo=tagInfoUpdateAtDate<seasons.Summer}else{shouldUpdateTagInfo=tagInfoUpdateAtDate<seasons.Fall}if(shouldUpdateTagInfo){getTagInfoData(tagInfo,data?.getData)}else{self.postMessage({done:true})}}else{getTagInfoData(null,data?.getData)}};async function getTagInfoData(tagInfo,getData){try{const response=await fetch("https://graphql.anilist.co",{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({query:`{MediaTagCollection{name category description}}`})});const result=await response?.json?.();const mediaTagCollection=result?.data?.MediaTagCollection||[];for(let i=0;i<mediaTagCollection?.length;i++){const tagCollected=mediaTagCollection?.[i];const description=tagCollected?.description;let category=tagCollected?.category;let tag=tagCollected?.name;if(typeof tag==="string"&&typeof category==="string"&&tag&&category){if(!isJsonObject(tagInfo)){tagInfo={};tagInfo[category]={}}else if(!isJsonObject(tagInfo?.[category])){tagInfo[category]={}}if(description&&typeof description==="string"){tagInfo[category][tag]=description}}}if(isJsonObject(tagInfo)&&!jsonIsEmpty(tagInfo)){await setIDBRecords({tagInfo:tagInfo,tagInfoUpdateAt:parseInt((new Date).getTime()/1e3)});if(getData){self.postMessage(await compressJSONToBlob(tagInfo))}else{self.postMessage({done:true})}}else{self.postMessage({done:true})}}catch{if(!await isConnected()){self.postMessage({done:true})}else{setTimeout(()=>getTagInfoData(tagInfo,getData),6e4)}}}function hasTagInfoData(tagInfo){for(let category in tagInfo){for(let tag in tagInfo[category]){return typeof tagInfo[category][tag]==="string"}return false}return false}function IDBInit(){return new Promise((resolve,reject)=>{try{const request=indexedDB.open("Kanshi.Media.Recommendations.AniList.W~uPtWCq=vG$TR:Zl^#t<vdS]I~N70",1);request.onsuccess=({target})=>{db=target.result;resolve()};request.onupgradeneeded=({target})=>{try{const{result,transaction}=target;const stores=["mediaEntries","mediaEntriesInfo","excludedMediaIds","mediaUpdateAt","mediaOptions","orderedMediaOptions","tagInfo","tagInfoUpdateAt","username","userMediaEntries","userMediaUpdateAt","recommendedMediaEntries","algorithmFilters","mediaCautions","hiddenMediaEntries","categories","selectedCategory","autoPlay","gridFullView","showRateLimit","showStatus","autoUpdate","autoExport","runnedAutoUpdateAt","runnedAutoExportAt","exportPathIsAvailable","shouldManageMedia","shouldProcessRecommendedEntries","nearestMediaReleaseAiringAt","recommendationError","visited","others"];for(const store of stores){result.createObjectStore(store)}transaction.oncomplete=()=>{db=result;resolve()}}catch(ex){console.error(ex);reject(ex);transaction.abort()}};request.onerror=ex=>{console.error(ex);reject(ex)}}catch(ex){console.error(ex);reject(ex)}})}function setIDBRecords(records){return new Promise(async(resolve,reject)=>{try{for(const key in records){if(isJsonObject(records[key])||records[key]instanceof Array){records[key]=await new Response(new Blob([JSON.stringify(records[key])]).stream().pipeThrough(new CompressionStream("gzip"))).blob()}else if(records[key]instanceof Blob){records[key]=await new Response(records[key].stream().pipeThrough(new CompressionStream("gzip"))).blob()}}const transaction=db.transaction(Object.keys(records),"readwrite");for(const key in records){const put=transaction.objectStore(key).put(records[key],key);put.onerror=ex=>{console.error(ex);reject(ex);transaction.abort()}}transaction.oncomplete=()=>resolve()}catch(ex){console.error(ex);reject(ex)}})}function getIDBRecords(recordKeys){return new Promise(async resolve=>{try{const transaction=db.transaction(recordKeys,"readonly");resolve(Object.fromEntries(await Promise.all(recordKeys.map(key=>{return new Promise(resolve=>{const get=transaction.objectStore(key).get(key);get.onsuccess=async()=>{let value=get.result;if(value instanceof Blob){value=await new Response(value.stream().pipeThrough(new DecompressionStream("gzip"))).json()}resolve([key,value])};get.onerror=ex=>{console.error(ex);resolve([key])}})}))))}catch(ex){console.error(ex);resolve()}})}function isJsonObject(obj){return Object.prototype.toString.call(obj)==="[object Object]"}function jsonIsEmpty(obj){for(const key in obj)return false;return true}function isConnected(url=server){if(typeof url==="string"&&url!==""){return new Promise(async resolve=>{if(await checkConnection(url))return resolve(true);else await new Promise(r=>setTimeout(r,5e3));return resolve(await checkConnection(url))})}else{const $connected=connected;if(typeof $connected==="boolean"){connected=null;return $connected}else{self.postMessage({getConnectionState:true});return true}}}async function checkConnection(url){try{if(navigator?.onLine!==false){const response=await fetch(url,{method:"HEAD",cache:"no-store"});return response?.ok}}catch{}return false}async function compressBlob(blob){return await new Response(blob.stream().pipeThrough(new CompressionStream("gzip"))).blob()}async function compressJSONToBlob(json){return await compressBlob(new Blob([JSON.stringify(json)]))}
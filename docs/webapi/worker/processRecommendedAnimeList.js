let db;const mediaRelationTypes=["source","adaptation","prequel","sequel","parent","side_story","summary","compilation","alternative","spin_off"];const minNumber=1-6e-17!==1?6e-17:Number.EPSILON;self.addEventListener("unhandledrejection",event=>{console.error(event?.reason);self.postMessage({error:event?.reason||"Something went wrong"})});self.onmessage=async({data})=>{try{if(!db)await IDBinit();self.postMessage({status:"Processing Recommendation List"});const animeEntries=await retrieveJSON("animeEntries")||{};const userData=await retrieveJSON("userData");const userEntries=(userData?.userEntries??await retrieveJSON("userEntries"))||[];let includedUserEntryCount=0;let contentFocused=false,includeUnknownVar=false,includeYear=true,includeAverageScore=false,minPopularity,minAverageScore,minSampleSize,sampleSize,tagRankLimit=minNumber,customUserScoreBase;let include={genres:{},tags:{},categories:{}},exclude={genres:{},tags:{},categories:{}};let algorithmFilters=data?.algorithmFilters;const hasNewAlgorithmFilter=algorithmFilters!=null;if(!hasNewAlgorithmFilter){algorithmFilters=await retrieveJSON("algorithmFilters")||[{filterType:"bool",optionName:"content focused",status:"included"}]}algorithmFilters.forEach(({status,filterType,optionName,optionCategory,optionValue})=>{if(status==="included"){if(filterType==="selection"){if(optionCategory==="genre"){include.genres["genre: "+optionName.toLowerCase()]=true}else if(optionCategory==="tag"){include.tags["tag: "+optionName.toLowerCase()]=true}else if(optionCategory==="tag category"){include.categories["tag category: "+optionName.toLowerCase()]=true}}else if(filterType==="bool"){if(optionName.toLowerCase()==="content focused"){contentFocused=true}else if(optionName.toLowerCase()==="inc. all factors"){includeUnknownVar=true}else if(optionName.toLowerCase()==="inc. average score"){includeAverageScore=true}else if(optionName.toLowerCase()==="exclude year"){includeYear=false}}else if(filterType==="number"){if(optionName.toLowerCase()==="min tag percentage"){let newTagRankLimit=parseFloat(optionValue);if(newTagRankLimit>0){tagRankLimit=newTagRankLimit}}else if(optionName.toLowerCase()==="scoring system"){customUserScoreBase=parseFloat(optionValue)}else if(optionName.toLowerCase()==="sample size"){sampleSize=parseFloat(optionValue)}else if(optionName.toLowerCase()==="min sample size"){minSampleSize=parseFloat(optionValue)}else if(optionName.toLowerCase()==="min popularity"){minPopularity=parseFloat(optionValue)}else if(optionName.toLowerCase()==="min average score"){minAverageScore=parseFloat(optionValue)}}}else if(status==="excluded"){if(filterType==="selection"){if(optionCategory==="genre"){exclude.genres["genre: "+optionName.toLowerCase()]=true}else if(optionCategory==="tag"){exclude.tags["tag: "+optionName.toLowerCase()]=true}else if(optionCategory==="tag category"){exclude.categories["tag category: "+optionName.toLowerCase()]=true}}}});self.postMessage({status:"Processing Recommendation List"});if(userEntries.length>=2){if(isJsonObject(userEntries[0])&&isJsonObject(userEntries[1])){userEntries.sort((a,b)=>{let x=a?.score!=null?a.score:-Infinity,y=b?.score!=null?b.score:-Infinity;if(x!==y)return y-x;x=a?.media?.popularity!=null?a.media.popularity:-Infinity;y=b?.media?.popularity!=null?b.media.popularity:-Infinity;return y-x})}}const minScoreValue=.01;let userScores,userScoreBase=100;let varScheme={genres:{},tags:{},studios:{}};let userEntriesStatus={};let averageScore=[];let year=[];let genresMeanCount={};let tagsMeanCount={};let studiosMeanCount={};let genresWithUpperCount={},genresWithUpperScore={},tagsWithUpperScore={},studiosWithUpperScore={};let maxOthersScore={genres:-Infinity,tags:-Infinity,studios:-Infinity},minOthersScore={genres:Infinity,tags:Infinity,studios:Infinity};let includedAnimeRelations={};self.postMessage({status:"Processing Recommendation List"});for(let i=0,l=userEntries.length;i<l;i++){loadProgress((i+1)/l*100*.3);let anime=userEntries[i].media;let animeID=anime?.id;let status=userEntries[i].status;let userScore=userEntries[i].score;let episodeProgress=userEntries[i].progress;let volumeProgress=userEntries[i].progressVolumes;if(animeID){if(!isJsonObject(userEntriesStatus[animeID])){userEntriesStatus[animeID]={}}if(status&&typeof status==="string"){userEntriesStatus[animeID].userStatus=status}if(userScore>0){userEntriesStatus[animeID].userScore=userScore}if(episodeProgress>0){userEntriesStatus[animeID].episodeProgress=episodeProgress}if(volumeProgress>0){userEntriesStatus[animeID].volumeProgress=volumeProgress}}let genres=anime?.genres||[];let tags=anime?.tags||[];let studios=anime?.studios?.edges?.filter?.(e=>e?.isMain)||[];if(userScore>0){if(includedAnimeRelations[animeID])continue;includedAnimeRelations[animeID]=true;let animeRelations=anime?.relations?.edges||[];if(animeRelations instanceof Array){if(animeRelations.length>0){animeRelations.forEach(e=>{let animeRelationType=e?.relationType;let relationID=e?.node?.id;if(typeof animeRelationType==="string"&&typeof relationID==="number"){if(mediaRelationTypes.includes(animeRelationType.trim().toLowerCase())){includedAnimeRelations[relationID]=true}}})}}++includedUserEntryCount;for(let j=0,jl=genres.length;j<jl;j++){let genre=genres[j];if(typeof genre==="string"){let fullGenre="genre: "+formatCustomString(genre.trim().toLowerCase());if((jsonIsEmpty(include.genres)||include.genres[fullGenre]||include.genres["genre: all"])&&!exclude.genres[fullGenre]&&!exclude.genres["genre: all"]){if(varScheme.genres[fullGenre]){varScheme.genres[fullGenre].userScore.push(userScore);++varScheme.genres[fullGenre].count}else{varScheme.genres[fullGenre]={userScore:[userScore],count:1}}if(genresMeanCount[fullGenre]){++genresMeanCount[fullGenre]}else{genresMeanCount[fullGenre]=1}}}}for(let j=0,jl=tags.length;j<jl;j++){let tagRank=tags[j]?.rank;if(!tagRank||tagRank<tagRankLimit)continue;let tag=tags[j]?.name;let tagCategory=tags[j]?.category;if(typeof tag==="string"&&typeof tagCategory==="string"){let fullTag="tag: "+formatCustomString(tag.trim().toLowerCase());let fullTagCategory="tag category: "+formatCustomString(tagCategory.trim().toLowerCase());if((jsonIsEmpty(include.categories)||include.categories[fullTagCategory]||include.categories["tag category: all"])&&!exclude.categories[fullTagCategory]&&!exclude.categories["tag category: all"]&&(jsonIsEmpty(include.tags)||include.tags[fullTag]||include.tags["tag: all"])&&!exclude.tags[fullTag]&&!exclude.tags["tag: all"]){let tagWeight=tagRank*.01;if(varScheme.tags[fullTag]){varScheme.tags[fullTag].userScore.push(userScore*tagWeight);varScheme.tags[fullTag].count=varScheme.tags[fullTag].count+tagWeight}else{varScheme.tags[fullTag]={userScore:[userScore*tagWeight],count:tagWeight}}if(tagsMeanCount[fullTag]){tagsMeanCount[fullTag]=tagsMeanCount[fullTag]+tagWeight}else{tagsMeanCount[fullTag]=tagWeight}}}}let includedStudios={};for(let j=0,jl=studios.length;j<jl;j++){let studio=studios[j]?.node?.name;if(typeof studio==="string"){if(includedStudios[studio])continue;includedStudios[studio]=true;let fullStudio="studio: "+formatCustomString(studio.trim().toLowerCase());if(varScheme.studios[fullStudio]){varScheme.studios[fullStudio].userScore.push(userScore);++varScheme.studios[fullStudio].count}else{varScheme.studios[fullStudio]={userScore:[userScore],count:1}}if(studiosMeanCount[fullStudio]){++studiosMeanCount[fullStudio]}else{studiosMeanCount[fullStudio]=1}}}if(isaN(anime?.averageScore)&&includeAverageScore){averageScore.push({userScore:userScore,averageScore:anime.averageScore})}let animeYear=anime?.seasonYear||anime?.startDate?.year||anime?.endDate?.year;if(isaN(parseFloat(animeYear))&&includeYear){year.push({userScore:userScore,year:parseFloat(animeYear)})}}}if(includedUserEntryCount<1||jsonIsEmpty(genresMeanCount)||jsonIsEmpty(tagsMeanCount)){varScheme={}}else{userScores=Object.values(userEntriesStatus).map(entry=>entry.userScore).filter(uscore=>uscore>0);let maxUserScore=getMax(userScores);userScoreBase=maxUserScore<=3?3:maxUserScore<=5?5:maxUserScore<=10?10:100;let genresUpperCount;if(typeof sampleSize==="number"&&sampleSize>=1){genresMeanCount=sampleSize}else{let genresMeanAndSTD=arrayMeanAndSTD(Object.values(genresMeanCount));genresMeanCount=genresMeanAndSTD.mean;genresUpperCount=genresMeanAndSTD.mean+genresMeanAndSTD.standardDeviation}if(minSampleSize>=0){genresMeanCount=Math.max(minSampleSize,genresMeanCount)}if(typeof sampleSize==="number"&&sampleSize>=1){tagsMeanCount=sampleSize}else{tagsMeanCount=arrayMean(Object.values(tagsMeanCount))}if(minSampleSize>=0){tagsMeanCount=Math.max(minSampleSize,tagsMeanCount)}if(typeof sampleSize==="number"&&sampleSize>=1){studiosMeanCount=sampleSize}else if(!jsonIsEmpty(studiosMeanCount)){studiosMeanCount=arrayMean(Object.values(studiosMeanCount))}else{studiosMeanCount=Math.min(3,includedUserEntryCount)}if(minSampleSize>=0){studiosMeanCount=Math.max(minSampleSize,studiosMeanCount)}varScheme.includeUnknownVar=!contentFocused&&includeUnknownVar;varScheme.minPopularity=minPopularity;varScheme.minAverageScore=minAverageScore;let genresKey=Object.keys(varScheme.genres);let genresMeanAndSTD=arrayMeanAndSTD(genresKey.map(genre=>arrayMean(varScheme.genres[genre].userScore)));let genresMean=genresMeanAndSTD.mean;let genresUpperScore=genresMeanAndSTD.mean+genresMeanAndSTD.standardDeviation;for(let i=0,l=genresKey.length;i<l;i++){let originalScore=arrayMean(varScheme.genres[genresKey[i]].userScore);let count=varScheme.genres[genresKey[i]].count;let score=originalScore;if(count>=genresUpperCount){genresWithUpperCount[genresKey[i]]=true}if(contentFocused||originalScore<genresMean||count<genresMeanCount){if(contentFocused||count<genresMeanCount){let Cweight=count/genresMeanCount;score=score*Cweight}if(contentFocused||originalScore<genresMean){let Sweight=originalScore/genresMean;score=score*Sweight}if(contentFocused){if(score>maxOthersScore.genres){maxOthersScore.genres=score}}if(score<minOthersScore.genres){minOthersScore.genres=score}}if(contentFocused){if(originalScore>=genresUpperScore){genresWithUpperScore[genresKey[i]]=true}}else{if(score>=genresUpperScore){genresWithUpperScore[genresKey[i]]=true}}varScheme.genres[genresKey[i]]=score}let tagsKey=Object.keys(varScheme.tags);let tagsMeanAndSTD=arrayMeanAndSTD(tagsKey.map(tag=>arrayMean(varScheme.tags[tag].userScore)));let tagsMean=tagsMeanAndSTD.mean;let tagsUpperScore=tagsMeanAndSTD.mean+tagsMeanAndSTD.standardDeviation;for(let i=0;i<tagsKey.length;i++){let originalScore=arrayMean(varScheme.tags[tagsKey[i]].userScore);let count=varScheme.tags[tagsKey[i]].count;let score=originalScore;if(contentFocused||originalScore<tagsMean||count<tagsMeanCount){if(contentFocused||count<tagsMeanCount){let Cweight=count/tagsMeanCount;score=score*Cweight}if(contentFocused||originalScore<tagsMean){let Sweight=originalScore/tagsMean;score=score*Sweight}if(contentFocused){if(score>maxOthersScore.tags){maxOthersScore.tags=score}}if(score<minOthersScore.tags){minOthersScore.tags=score}}if(contentFocused){if(originalScore>=tagsUpperScore){tagsWithUpperScore[tagsKey[i]]=true}}else{if(score>=tagsUpperScore){tagsWithUpperScore[tagsKey[i]]=true}}varScheme.tags[tagsKey[i]]=score}let studiosKey=Object.keys(varScheme.studios);let studiosMeanAndSTD=arrayMeanAndSTD(studiosKey.map(studio=>arrayMean(varScheme.studios[studio].userScore)));let studiosMean=studiosMeanAndSTD.mean;let studiosUpperScore=studiosMeanAndSTD.mean+studiosMeanAndSTD.standardDeviation;for(let i=0,l=studiosKey.length;i<l;i++){let originalScore=arrayMean(varScheme.studios[studiosKey[i]].userScore);let count=varScheme.studios[studiosKey[i]].count;let score=originalScore;if(contentFocused||originalScore<studiosMean||count<studiosMeanCount){if(contentFocused||count<studiosMeanCount){let Cweight=count/studiosMeanCount;score=score*Cweight}if(contentFocused||originalScore<studiosMean){let Sweight=originalScore/studiosMean;score=score*Sweight}if(contentFocused){if(score>maxOthersScore.studios){maxOthersScore.studios=score}}if(score<minOthersScore.studios){minOthersScore.studios=score}}if(contentFocused){if(originalScore>=studiosUpperScore){studiosWithUpperScore[studiosKey[i]]=true}}else{if(score>=studiosUpperScore){studiosWithUpperScore[studiosKey[i]]=true}}varScheme.studios[studiosKey[i]]=score}varScheme.genresMean=genresMean;varScheme.tagsMean=tagsMean;varScheme.includeCategories=include.categories;varScheme.excludeCategories=exclude.categories;varScheme.includeGenres=include.genres;varScheme.excludeGenres=exclude.genres;varScheme.includeTags=include.tags;varScheme.excludeTags=exclude.tags;if(includeYear){let yearXY=[];for(let i=0,l=year.length;i<l;i++){yearXY.push([year[i].year,year[i].userScore])}if(yearXY.length>=(minSampleSize||33)){varScheme.yearModel=linearRegression(yearXY)}}if(includeAverageScore){let averageScoreXY=[];for(let i=0,l=averageScore.length;i<l;i++){averageScoreXY.push([averageScore[i].averageScore,averageScore[i].userScore])}if(averageScoreXY.length>=(minSampleSize||33)){varScheme.averageScoreModel=linearRegression(averageScoreXY)}}}self.postMessage({status:"Processing Recommendation List"});let recommendedAnimeListArray=[];let newHighestRange=userScoreBase,newLowestRange=minScoreValue,maxScore=-Infinity,minScore=Infinity,maxWeightedScore=-Infinity,minWeightedScore=Infinity;let meanUserScore,meanScoreAll,meanScoreAbove;let animeEntriesArray=Object.values(animeEntries??{});let averageScoresArray=[],maxAverageScore=-Infinity,popularityArray=[];for(let i=0,l=animeEntriesArray.length;i<l;i++){let anime=animeEntriesArray[i];let averageScore=anime.averageScore;if(averageScore>0){if(averageScore>maxAverageScore){maxAverageScore=averageScore}averageScoresArray.push(averageScore)}let popularity=anime.popularity;if(popularity>=1){popularityArray.push(popularity)}}let popularityMode=varScheme?.minPopularity?varScheme.minPopularity:arrayMode(popularityArray);let averageScoreMode=varScheme?.minAverageScore?varScheme.minAverageScore:arrayMode(averageScoresArray);let dayInMillis=1e3*60*60*24;self.postMessage({popularityMode:popularityMode,averageScoreMode:averageScoreMode});let filters=await retrieveJSON("filters");if(!jsonIsEmpty(varScheme)&&userScores?.length>0){meanUserScore=arrayMean(userScores);let{standardDeviation,mean}=arrayMeanAndSTD(userScores.filter(score=>score>1));if(customUserScoreBase>0&&customUserScoreBase!==userScoreBase){standardDeviation=mapValue(standardDeviation,minScoreValue,userScoreBase,minScoreValue,customUserScoreBase);mean=mapValue(mean,minScoreValue,userScoreBase,minScoreValue,customUserScoreBase)}newHighestRange=mean+standardDeviation;newLowestRange=mean-standardDeviation;for(let i=0,l=animeEntriesArray.length;i<l;i++){loadProgress(i/l*100*.7+30);let anime=animeEntriesArray[i];let animeID=anime?.id;let animeUrl=anime?.siteUrl;let format=anime?.format;let countryOfOrigin=anime?.countryOfOrigin;let year=anime?.seasonYear||anime?.startDate?.year||anime?.endDate?.year;let season=anime?.season;let genres=anime?.genres||[];let tags=anime?.tags||[];let studios=anime?.studios?.edges?.filter?.(e=>e?.isMain)||[];let status=anime?.status;let popularity=anime?.popularity;let userStatus="UNWATCHED";if(typeof userEntriesStatus?.[animeID]?.userStatus==="string"){userStatus=userEntriesStatus?.[animeID]?.userStatus;let tmpUserStatus=userStatus.trim().toLowerCase();if(tmpUserStatus&&filters?.["user status"]&&filters?.["user status"]?.[tmpUserStatus]===undefined){filters["user status"][tmpUserStatus]=true}}if(typeof status==="string"){let tempStatus=status.trim().toLowerCase();if(tempStatus&&filters?.["airing status"]&&filters?.["airing status"]?.[tempStatus]===undefined){filters["airing status"][tempStatus]=true}}if(typeof format==="string"){let tempFormat=format.trim().toLowerCase();if(tempFormat&&filters?.format&&filters?.format?.[tempFormat]===undefined){filters.format[tempFormat]=true}}if(typeof countryOfOrigin==="string"){let tempCountryOfOrigin=countryOfOrigin.trim().toLowerCase();if(tempCountryOfOrigin&&filters?.["country of origin"]&&filters?.["country of origin"]?.[tempCountryOfOrigin]===undefined){filters["country of origin"][tempCountryOfOrigin]=true}}if(year){let tempYear=year?.toString?.().trim().toLowerCase();if(tempYear&&filters?.year&&filters?.year?.[tempYear]===undefined){filters.year[tempYear]=true}}let favouriteGenresIncluded={},favouriteTagsIncluded={},favouriteStudiosIncluded={},genresIncluded={},tagsIncluded={},studiosIncluded={};let zgenres=[];for(let j=0,jl=genres.length;j<jl;j++){let genre=genres[j];if(typeof genre!=="string")continue;genre=formatCustomString(genre.trim().toLowerCase());let fullGenre="genre: "+genre;if((jsonIsEmpty(varScheme.includeGenres)||varScheme.includeGenres[fullGenre]||varScheme.includeGenres["genre: all"])&&!varScheme.excludeGenres[fullGenre]&&!varScheme.excludeGenres["genre: all"]){if(typeof varScheme.genres[fullGenre]==="number"){zgenres.push({genre:fullGenre,score:varScheme.genres[fullGenre]});if(!favouriteGenresIncluded[genre]&&!genresIncluded[genre]){let tmpscore=varScheme.genres[fullGenre];if(genresWithUpperCount?.[fullGenre]||genresWithUpperScore?.[fullGenre]){favouriteGenresIncluded[genre]=tmpscore}else{genresIncluded[genre]=tmpscore}}}else if(typeof varScheme.genresMean==="number"&&varScheme.includeUnknownVar){zgenres.push({genre:fullGenre,score:varScheme.genresMean})}}if(genre&&filters?.genre&&filters?.genre?.[genre]===undefined){filters.genre[genre]=true}}let ztags=[];for(let j=0,jl=tags.length;j<jl;j++){let tag=tags[j]?.name;if(typeof tag!=="string")continue;let tagCategory=tags[j]?.category;if(typeof tagCategory!=="string")continue;let tagRank=tags[j]?.rank;tag=formatCustomString(tag.trim().toLowerCase());let fullTag="tag: "+tag;tagCategory=formatCustomString(tagCategory.trim().toLowerCase());let fullTagCategory="tag category: "+tagCategory;if((jsonIsEmpty(varScheme.includeCategories)||varScheme.includeCategories[fullTagCategory]||varScheme.includeCategories["tag category: all"])&&!varScheme.excludeCategories[fullTagCategory]&&!varScheme.excludeCategories["tag category: all"]&&(jsonIsEmpty(varScheme.includeTags)||varScheme.includeTags[fullTag]||varScheme.includeTags["tag: all"])&&!varScheme.excludeTags[fullTag]&&!varScheme.excludeTags["tag: all"]){if(typeof varScheme.tags[fullTag]==="number"&&typeof tagRank==="number"){if(tagRank&&tagRank>=tagRankLimit){let tagWeight=tagRank*.01;ztags.push(varScheme.tags[fullTag]*tagWeight)}if(!favouriteTagsIncluded[tag]&&!tagsIncluded[tag]){let tmpscore=varScheme.tags[fullTag];if(tagsWithUpperScore?.[fullTag]){favouriteTagsIncluded[tag]=tmpscore}else{tagsIncluded[tag]=tmpscore}}}else if(typeof varScheme.tagsMean==="number"&&varScheme.includeUnknownVar){ztags.push(varScheme.tagsMean)}}if(tag&&filters?.tag&&filters?.tag?.[tag]===undefined){filters.tag[tag]=true}if(tagCategory&&filters?.["tag category"]&&filters?.["tag category"]?.[tagCategory]===undefined){filters["tag category"][tagCategory]=true}}let includedStudios={};for(let j=0,jl=studios.length;j<jl;j++){let studio=studios[j]?.node?.name;if(typeof studio!=="string")continue;if(includedStudios[studio])continue;includedStudios[studio]=true;studio=formatCustomString(studio.trim().toLowerCase());let fullStudio="studio: "+studio;if(typeof varScheme.studios[fullStudio]==="number"){if(!favouriteStudiosIncluded[studio]&&!studiosIncluded[studio]){let tmpscore=varScheme.studios[fullStudio];if(studiosWithUpperScore?.[fullStudio]){favouriteStudiosIncluded[studio]=tmpscore}else{studiosIncluded[studio]=tmpscore}}}if(studio&&filters?.studio&&filters?.studio?.[studio]===undefined){filters.studio[studio]=true}}let animeQuality=[];let yearModel=varScheme.yearModel??{};if(isaN(year)&&!jsonIsEmpty(yearModel)&&includeYear&&yearModel?.slope>0){let seasonYear=year;if(typeof seasonYear==="string"){seasonYear=parseFloat(seasonYear)}let modelScore=LRpredict(yearModel,seasonYear);if(modelScore>=minScoreValue){animeQuality.push(modelScore)}else{animeQuality.push(minScoreValue)}}else{animeQuality.push(minScoreValue)}let averageScore=anime?.averageScore;let averageScoreModel=varScheme.averageScoreModel??{};if(isaN(averageScore)&&!jsonIsEmpty(averageScoreModel)&&includeAverageScore&&averageScoreModel?.slope>0){if(typeof averageScore==="string"){averageScore=parseFloat(averageScore)}let modelScore=LRpredict(averageScoreModel,averageScore);if(modelScore>=minScoreValue){animeQuality.push(modelScore)}else{animeQuality.push(minScoreValue)}}else{animeQuality.push(minScoreValue)}let episodes=anime?.episodes;let duration=anime?.duration;let animeContent=[];if(zgenres.length){let genreValues=zgenres.reduce((acc,_genre)=>{acc.push(_genre.score);return acc},[]);if(zgenres.some(e=>!genresWithUpperCount[e.genre])){animeContent.push(arrayMean(genreValues))}else{animeContent.push(getMax(genreValues))}}else{animeContent.push(minScoreValue)}if(ztags.length){animeContent.push(arrayMean(ztags))}else{animeContent.push(minScoreValue)}let finalAnimeQuality=animeQuality.length?arrayMean(animeQuality):minScoreValue;let finalAnimeContent=animeContent.length?arrayMean(animeContent):minScoreValue;let score=finalAnimeContent*finalAnimeQuality;genres=genres.length?genres:[];tags=tags.length?tags.map(e=>{return{name:e?.name,rank:e?.rank}}):[];studios=studios.reduce((result,e)=>Object.assign(result,{[formatCustomString(e?.node?.name)]:e?.node?.siteUrl}),{});let weightedScore;if(averageScore>0){if(score>0&&averageScore<averageScoreMode){let ASweight=averageScore/averageScoreMode;weightedScore=score*ASweight}else{weightedScore=score}}let newScore=weightedScore!==score?weightedScore:score;if(popularity>0&&popularityMode>0){if(newScore>0&&popularity<popularityMode){let PSweight=popularity/popularityMode;weightedScore=score*PSweight}else{weightedScore=newScore}}if(!weightedScore||weightedScore<=0||!isFinite(weightedScore)){weightedScore=minScoreValue}if(!score||score<=0||!isFinite(score)){score=minScoreValue}if(score>maxScore){maxScore=score}if(score<minScore){minScore=score}if(weightedScore>maxWeightedScore){maxWeightedScore=weightedScore}if(weightedScore<minWeightedScore){minWeightedScore=weightedScore}if(typeof anime?.nextAiringEpisode?.episode==="number"&&!isNaN(anime?.nextAiringEpisode?.episode)&&typeof anime?.nextAiringEpisode?.airingAt==="number"&&!isNaN(anime?.nextAiringEpisode?.airingAt)){let airingAt=anime?.nextAiringEpisode?.airingAt;if(anime?.nextAiringEpisode?.episode===episodes){let airingAtDate=new Date(airingAt*1e3);let currentDate=new Date;if(airingAtDate<=currentDate){anime.nextAiringEpisode=null;status="FINISHED"}else if(airingAtDate>currentDate){self.postMessage({animeCompletionAiringAt:anime?.nextAiringEpisode?.airingAt})}}if(isJsonObject(anime.nextAiringEpisode)){let _releaseDateMillis=airingAt*1e3;if((!equalsNCS(userStatus,"UNWATCHED")||weightedScore>minScoreValue)&&typeof _releaseDateMillis==="number"&&_releaseDateMillis>=(new Date).getTime()-dayInMillis){let _title=anime?.title?.english||anime?.title?.userPreferred||anime?.title?.romaji||anime?.title?.native;let _releaseEpisode=anime?.nextAiringEpisode?.episode;let _imageURL=anime?.coverImage?.large||"";let _episodeProgress=userEntriesStatus?.[animeID]?.episodeProgress||0;self.postMessage({animeReleaseNotification:{id:animeID,title:typeof _title==="string"?_title:"",releaseEpisodes:_releaseEpisode,maxEpisode:typeof episodes==="number"?episodes:-1,releaseDateMillis:_releaseDateMillis,userStatus:typeof userStatus==="string"?userStatus:"UNWATCHED",imageURL:typeof _imageURL==="string"?_imageURL:"",animeUrl:typeof animeUrl==="string"?animeUrl:"",episodeProgress:typeof _episodeProgress==="number"?_episodeProgress:0}})}}}else if(jsonIsEmpty(anime.nextAiringEpisode)&&!(ncsCompare(status,"finished")||ncsCompare(status,"cancelled"))&&year){let{month,day}=anime?.startDate||{};if(parseInt(month)>0){month=parseInt(month)-1}let possibleAiringDate=getJapaneseStartDate({season:season,year:year,month:month,day:day});if(possibleAiringDate&&possibleAiringDate>new Date){anime.nextAiringEpisode={airingAt:Math.floor(possibleAiringDate.getTime()/1e3),episode:1}}}let favoriteContents={genres:favouriteGenresIncluded,tags:favouriteTagsIncluded,studios:favouriteStudiosIncluded};let otherContents={genres:genresIncluded,tags:tagsIncluded,studios:studiosIncluded};recommendedAnimeListArray.push({id:animeID,title:anime?.title,animeUrl:animeUrl,userScore:userEntriesStatus?.[animeID]?.userScore,animeRelations:anime?.relations?.edges,averageScore:averageScore,popularity:popularity,trending:anime?.trending,favorites:anime?.favourites,score:score,weightedScore:weightedScore,favoriteContents:favoriteContents,otherContents:otherContents,userStatus:formatCustomString(userStatus),status:formatCustomString(status),description:anime?.description,genres:genres.map(e=>formatCustomString(e)),tags:tags.map(e=>formatCustomString(e)),dateAdded:anime?.dateAdded,dateEdited:anime?.dateEdited,startDate:anime?.startDate,year:year,season:formatCustomString(season),format:formatCustomString(format),studios:studios,episodes:episodes,episodeProgress:userEntriesStatus?.[animeID]?.episodeProgress,volumeProgress:userEntriesStatus?.[animeID]?.volumeProgress,duration:duration,chapters:anime?.chapters,volumes:anime?.volumes,countryOfOrigin:formatCustomString(countryOfOrigin),coverImageUrl:anime?.coverImage?.large,trailerID:anime?.trailer?.id,bannerImageUrl:anime?.bannerImage,trailerThumbnailUrl:anime?.trailer?.thumbnail,nextAiringEpisode:anime?.nextAiringEpisode})}}else{let{standardDeviation,mean}=arrayMeanAndSTD(averageScoresArray);if(customUserScoreBase>0&&averageScoresArray?.length>0){const averageScoreBase=maxAverageScore<=3?3:maxAverageScore<=5?5:maxAverageScore<=10?10:100;if(customUserScoreBase!==averageScoreBase){standardDeviation=mapValue(standardDeviation,minScoreValue,averageScoreBase,minScoreValue,customUserScoreBase);mean=mapValue(mean,minScoreValue,averageScoreBase,minScoreValue,customUserScoreBase)}}newHighestRange=mean+standardDeviation;newLowestRange=mean-standardDeviation;for(let i=0,l=animeEntriesArray.length;i<l;i++){loadProgress(i/l*100);let anime=animeEntriesArray[i];let animeID=anime?.id;let animeUrl=anime?.siteUrl;let format=anime?.format;let countryOfOrigin=anime?.countryOfOrigin;let year=anime?.seasonYear||anime?.startDate?.year||anime?.endDate?.year;let season=anime?.season;let genres=anime?.genres||[];let tags=anime?.tags||[];let studios=anime?.studios?.edges?.filter?.(e=>e?.isMain)||[];let status=anime?.status;let episodes=anime?.episodes;let duration=anime?.duration;if(typeof status==="string"){let tempStatus=status.trim().toLowerCase();if(tempStatus&&filters?.["airing status"]&&filters?.["airing status"]?.[tempStatus]===undefined){filters["airing status"][tempStatus]=true}}if(typeof format==="string"){let tempFormat=format.trim().toLowerCase();if(tempFormat&&filters?.format&&filters?.format?.[tempFormat]===undefined){filters.format[tempFormat]=true}}if(typeof countryOfOrigin==="string"){let tempCountryOfOrigin=countryOfOrigin.trim().toLowerCase();if(tempCountryOfOrigin&&filters?.["country of origin"]&&filters?.["country of origin"]?.[tempCountryOfOrigin]===undefined){filters["country of origin"][tempCountryOfOrigin]=true}}if(year){let tempYear=year?.toString?.().trim().toLowerCase();if(tempYear&&filters?.year&&filters?.year?.[tempYear]===undefined){filters.year[tempYear]=true}}for(let j=0,jl=genres.length;j<jl;j++){let genre=genres[j];if(typeof genre!=="string")continue;genre=genre.trim().toLowerCase();if(genre&&filters?.genre&&filters?.genre?.[genre]===undefined){filters.genre[genre]=true}}for(let j=0,jl=tags.length;j<jl;j++){let tag=tags[j]?.name;if(typeof tag!=="string")continue;tag=tag.trim().toLowerCase();if(tag&&filters?.tag&&filters?.tag?.[tag]===undefined){filters.tag[tag]=true}let tagCategory=tags[j]?.category;if(typeof tagCategory!=="string")continue;tagCategory=tagCategory.trim().toLowerCase();if(tagCategory&&filters?.["tag category"]&&filters?.["tag category"]?.[tagCategory]===undefined){filters["tag category"][tagCategory]=true}}for(let j=0,jl=studios.length;j<jl;j++){let studio=studios[j]?.node?.name;if(typeof studio!=="string")continue;studio=studio.trim().toLowerCase();if(studio&&filters?.studio&&filters?.studio?.[studio]===undefined){filters.studio[studio]=true}}let score=minScoreValue;let averageScore=anime?.averageScore;if(isaN(averageScore)){if(typeof averageScore==="string"){averageScore=parseFloat(averageScore)}}let favourites=anime?.favourites;if(isaN(favourites)){if(typeof favourites==="string"){favourites=parseFloat(favourites)}}let popularity=anime?.popularity;if(isaN(popularity)){if(typeof popularity==="string"){popularity=parseFloat(popularity)}}if(averageScore>0&&favourites>0&&popularity>0&&isaN(averageScore)&&isaN(favourites)&&isaN(popularity)){let favPopRatio=Math.min(favourites,popularity)/popularity;score=favPopRatio*averageScore}genres=genres.length?genres:[];tags=tags.length?tags.map(e=>{return{name:e?.name,rank:e?.rank}}):[];studios=studios.reduce((result,e)=>Object.assign(result,{[formatCustomString(e?.node?.name)]:e?.node?.siteUrl}),{});let weightedScore;if(averageScore>0){if(score>0&&averageScore<averageScoreMode){let ASweight=averageScore/averageScoreMode;weightedScore=score*ASweight}else{weightedScore=score}}let newScore=weightedScore!==score?weightedScore:score;if(popularity>0&&popularityMode>0){if(newScore>0&&popularity<popularityMode){let PSweight=popularity/popularityMode;weightedScore=score*PSweight}else{weightedScore=newScore}}if(!weightedScore||weightedScore<=0||!isFinite(weightedScore)){weightedScore=minScoreValue}if(!score||score<=0||!isFinite(score)){score=minScoreValue}if(score>maxScore){maxScore=score}if(score<minScore){minScore=score}if(weightedScore>maxWeightedScore){maxWeightedScore=weightedScore}if(weightedScore<minWeightedScore){minWeightedScore=weightedScore}if(typeof anime?.nextAiringEpisode?.episode==="number"&&!isNaN(anime?.nextAiringEpisode?.episode)&&typeof anime?.nextAiringEpisode?.airingAt==="number"&&!isNaN(anime?.nextAiringEpisode?.airingAt)){let airingAt=anime?.nextAiringEpisode?.airingAt;if(anime?.nextAiringEpisode?.episode===episodes){let airingAtDate=new Date(airingAt*1e3);let currentDate=new Date;if(airingAtDate<=currentDate){anime.nextAiringEpisode=null;status="FINISHED"}else if(airingAtDate>currentDate){self.postMessage({animeCompletionAiringAt:anime?.nextAiringEpisode?.airingAt})}}if(isJsonObject(anime.nextAiringEpisode)){let _releaseDateMillis=airingAt*1e3;if(weightedScore>minScoreValue&&typeof _releaseDateMillis==="number"&&_releaseDateMillis>=(new Date).getTime()-dayInMillis){let _title=anime?.title?.english||anime?.title?.userPreferred||anime?.title?.romaji||anime?.title?.native;let _releaseEpisode=anime?.nextAiringEpisode?.episode;let _imageURL=anime?.coverImage?.large||"";self.postMessage({animeReleaseNotification:{id:animeID,title:typeof _title==="string"?_title:"",releaseEpisodes:_releaseEpisode,maxEpisode:typeof episodes==="number"?episodes:-1,releaseDateMillis:_releaseDateMillis,userStatus:"UNWATCHED",imageURL:typeof _imageURL==="string"?_imageURL:"",animeUrl:typeof animeUrl==="string"?animeUrl:"",episodeProgress:0}})}}}else if(jsonIsEmpty(anime.nextAiringEpisode)&&!(ncsCompare(status,"finished")||ncsCompare(status,"cancelled"))&&year){let{month,day}=anime?.startDate||{};if(parseInt(month)>0){month=parseInt(month)-1}let possibleAiringDate=getJapaneseStartDate({season:season,year:year,month:month,day:day});if(possibleAiringDate&&possibleAiringDate>new Date){anime.nextAiringEpisode={airingAt:Math.floor(possibleAiringDate.getTime()/1e3),episode:1}}}recommendedAnimeListArray.push({id:animeID,title:anime?.title,animeUrl:animeUrl,animeRelations:anime?.relations?.edges,averageScore:averageScore,popularity:popularity,trending:anime?.trending,favorites:anime?.favourites,score:score,weightedScore:weightedScore,userStatus:"UNWATCHED",status:formatCustomString(status),description:anime?.description,genres:genres.map(e=>formatCustomString(e)),tags:tags.map(e=>formatCustomString(e)),dateAdded:anime?.dateAdded,dateEdited:anime?.dateEdited,startDate:anime?.startDate,year:year,season:formatCustomString(season),format:formatCustomString(format),studios:studios,episodes:episodes,duration:duration,chapters:anime?.chapters,volumes:anime?.volumes,countryOfOrigin:formatCustomString(countryOfOrigin),coverImageUrl:anime?.coverImage?.large,trailerID:anime?.trailer?.id,bannerImageUrl:anime?.bannerImage,trailerThumbnailUrl:anime?.trailer?.thumbnail,nextAiringEpisode:anime?.nextAiringEpisode})}}let userAnimeScores=[],userAnimeUserScores=[];let userScoresAnimes=[],scoresArray=[],scoreAboveMeanArray=[];newLowestRange=newLowestRange>0?newLowestRange:minScoreValue;if(customUserScoreBase>0){newHighestRange=Math.min(customUserScoreBase,newHighestRange)}else{newHighestRange=Math.min(userScoreBase,newHighestRange)}for(let key in minOthersScore){minOthersScore[key]=minOthersScore[key]>0&&isFinite(minOthersScore[key])?minOthersScore[key]:minScoreValue}if(contentFocused){for(let key in maxOthersScore){maxOthersScore[key]=isFinite(maxOthersScore[key])?maxOthersScore[key]:userScoreBase}}else{for(let key in maxOthersScore){maxOthersScore[key]=maxOthersScore[key]<=userScoreBase&&isFinite(maxOthersScore[key])?maxOthersScore[key]:userScoreBase}}recommendedAnimeListArray=recommendedAnimeListArray.map(anime=>{anime.score=mapValue(anime.score,minScore,maxScore,newLowestRange,newHighestRange);anime.weightedScore=mapValue(anime.weightedScore,minWeightedScore,maxWeightedScore,newLowestRange,newHighestRange);if(isJsonObject(anime.favoriteContents)&&!jsonIsEmpty(anime.favoriteContents)){const{genres,tags,studios}=anime.favoriteContents;for(const genre in genres){anime.favoriteContents.genres[genre]=mapValue(genres[genre],minOthersScore.genres,maxOthersScore.genres,newLowestRange,newHighestRange)}for(const tag in tags){anime.favoriteContents.tags[tag]=mapValue(tags[tag],minOthersScore.tags,maxOthersScore.tags,newLowestRange,newHighestRange)}for(const studio in studios){anime.favoriteContents.studios[studio]=mapValue(studios[studio],minOthersScore.studios,maxOthersScore.studios,newLowestRange,newHighestRange)}}if(isJsonObject(anime.otherContents)&&!jsonIsEmpty(anime.otherContents)){const{genres,tags,studios}=anime.otherContents;for(const genre in genres){anime.otherContents.genres[genre]=mapValue(genres[genre],minOthersScore.genres,maxOthersScore.genres,newLowestRange,newHighestRange)}for(const tag in tags){anime.otherContents.tags[tag]=mapValue(tags[tag],minOthersScore.tags,maxOthersScore.tags,newLowestRange,newHighestRange)}for(const studio in studios){anime.otherContents.studios[studio]=mapValue(studios[studio],minOthersScore.studios,maxOthersScore.studios,newLowestRange,newHighestRange)}}if(anime.userScore!=null&&anime.userScore>0){if(anime.userScore>=meanUserScore){scoreAboveMeanArray.push(anime.score)}userScoresAnimes.push(anime);if(anime.userScore>1){userAnimeScores.push(anime.score);userAnimeUserScores.push(anime.userScore)}}scoresArray.push(anime.score);return anime});if(scoresArray?.length){meanScoreAll=arrayMean(scoresArray)}if(scoreAboveMeanArray?.length){meanScoreAbove=arrayMean(scoreAboveMeanArray)}let recommendedAnimeList={};for(let i=0,l=recommendedAnimeListArray.length;i<l;i++){let anime=recommendedAnimeListArray[i];let animeID=anime.id;anime.meanScoreAll=meanScoreAll>=newLowestRange?meanScoreAll:newLowestRange;anime.meanScoreAbove=meanScoreAbove>=newLowestRange?meanScoreAbove:newLowestRange;recommendedAnimeList[animeID]=anime}if(hasNewAlgorithmFilter){await saveJSON(algorithmFilters,"algorithmFilters")}await saveJSON(recommendedAnimeList||{},"recommendedAnimeList");await saveJSON(filters,"filters");let recListMAPE=calculateMAPE(userAnimeUserScores,userAnimeScores);if(recListMAPE!=null){await saveJSON(recListMAPE,"recListMAPE");self.postMessage({recListMAPE:recListMAPE})}await saveJSON(true,"shouldLoadAnime");await saveJSON(false,"shouldProcessRecommendation");self.postMessage({status:null});self.postMessage({progress:100});self.postMessage({message:"success",hasPassedFilters:data?.hasPassedFilters})}catch(err){console.error(err);self.postMessage({error:err||"Something went wrong"})}};function formatCustomString(str){if(typeof str==="string"){str=str!=="_"?str.replace(/\_/g," "):str;str=str!=='\\"'?str.replace(/\\"/g,'"'):str;str=str.replace(/\b(tv|ona|ova)\b/gi,match=>match.toUpperCase())}return str}function jsonIsEmpty(obj){for(const key in obj){return false}return true}function equalsNCS(str1,str2){let s1=str1;let s2=str2;if(typeof s1==="number")s1=s1.toString();if(typeof s2==="number")s2=s2.toString();if(typeof s1==="string")s1=s1.trim().toLowerCase();if(typeof s2==="string")s2=s2.trim().toLowerCase();return s1===s2}function isaN(num){if(!num&&num!==0){return false}else if(typeof num==="boolean"){return false}else if(typeof num==="string"&&!num){return false}return!isNaN(num)}function isJson(j){try{return j?.constructor.name==="Object"&&`${j}`==="[object Object]"}catch(e){return false}}function mapValue(originalValue,lowestValue,highestValue,newLowestRange,newHighestRange){let mappedValue=(originalValue-lowestValue)*(newHighestRange-newLowestRange)/(highestValue-lowestValue)+newLowestRange;return mappedValue}function arrayMeanAndSTD(obj){if(obj.length===0)return 0;const mean=arrayMean(obj);return{mean:mean,standardDeviation:Math.sqrt(obj.reduce((sum,value)=>sum+Math.pow(value-mean,2),0)/obj.length)}}function arrayMean(obj){return arraySum(obj)/obj.length||0}function arraySum(obj){return obj.reduce((a,b)=>a+b,0)}function arrayMedian(arr){const sortedArr=arr.slice().sort((a,b)=>a-b);const n=sortedArr.length;if(n%2===0){const middleRight=n/2;const middleLeft=middleRight-1;return(sortedArr[middleLeft]+sortedArr[middleRight])/2}else{const middle=Math.floor(n/2);return sortedArr[middle]}}function arrayMode(obj){if(obj.length===0){return}else if(obj.length===1){return obj[0]}else if(obj.length===2){return(obj[0]+obj[1])/2}let max=parseFloat(getMax(obj));let min=parseFloat(getMin(obj));const boundary=minNumber;let classW=parseFloat((max-min)/(1+3.322*Math.log(obj.length)));let classIs=[];if(max===min||classW<boundary){classIs=[{low:min,high:max,freq:0}]}else{let high=min+classW-boundary,low=min;classIs=[{low:low,high:high,freq:0}];while(classIs.slice(-1)[0].high<max){low=high+boundary;high=low+classW-boundary;classIs.push({low:low,high:high,freq:0})}}for(let i=0,l=obj.length;i<l;i++){let num=obj[i];for(let j=0,jl=classIs.length;j<jl;j++){if(num>=classIs[j].low&&num<=classIs[j].high){++classIs[j].freq;continue}}}let modeClass=classIs[0];let modeIdx=0;for(let i=1,l=classIs.length;i<l;i++){if(classIs[i].freq>modeClass.freq){modeClass=classIs[i];modeIdx=i}}let modLowLim=modeClass.low;let modFreq=modeClass.freq;let modPreFreq=!classIs[modeIdx-1]?0:classIs[modeIdx-1].freq;let modSucFreq=!classIs[modeIdx+1]?0:classIs[modeIdx+1].freq;return modLowLim+(modFreq-modPreFreq)/(2*modFreq-modPreFreq-modSucFreq)*classW}function arrayProbability(obj){if(!obj?.length)return 0;return obj.reduce((a,b)=>a*b,1)}function getMax(arr){let len=arr.length;let max=-Infinity;while(len--){max=arr[len]>max?arr[len]:max}return max}function getMin(arr){let len=arr.length;let min=Infinity;while(len--){min=arr[len]<min?arr[len]:min}return min}function filterArrayByMeanPercentages(numbers,parseToInt){const counts=numbers.reduce((acc,num)=>{const finNum=parseToInt?Math.floor(num):num;acc[finNum]=acc[finNum]?acc[finNum]+1:1;return acc},{});let countsLen=0;for(const num in counts){countsLen+=counts[num]||0}if(countsLen>0){for(const num in counts){counts[num]=counts[num]/countsLen}const CTPercentage=arrayMean(Object.values(counts));return numbers.filter(num=>{const finNum=parseToInt?Math.floor(num):num;return counts[finNum]<=CTPercentage})}else{return[]}}function linearRegression(XY){let lr={};let n=XY.length;let sum_x=0;let sum_y=0;let sum_xy=0;let sum_xx=0;let sum_yy=0;for(let i=0,l=XY.length;i<l;i++){sum_x+=XY[i][0];sum_y+=XY[i][1];sum_xy+=XY[i][0]*XY[i][1];sum_xx+=XY[i][0]*XY[i][0];sum_yy+=XY[i][1]*XY[i][1]}lr["slope"]=(n*sum_xy-sum_x*sum_y)/(n*sum_xx-sum_x*sum_x);lr["intercept"]=(sum_y-lr.slope*sum_x)/n;lr["r2"]=Math.pow((n*sum_xy-sum_x*sum_y)/Math.sqrt((n*sum_xx-sum_x*sum_x)*(n*sum_yy-sum_y*sum_y)),2);return lr}function LRpredict(modelObj,x){if(!modelObj)return null;if(!modelObj.slope||!modelObj.intercept)return null;if(isNaN(modelObj.slope)||isNaN(modelObj.intercept))return null;return parseFloat(modelObj.slope)*x+parseFloat(modelObj.intercept)}function LRpredictInverse(modelObj,y){if(!modelObj)return null;if(!modelObj.slope||!modelObj.intercept)return null;if(isNaN(modelObj.slope)||isNaN(modelObj.intercept))return null;if(parseFloat(modelObj.slope)===0)return null;return(parseFloat(y)-parseFloat(modelObj.intercept))/parseFloat(modelObj.slope)}function calculateMAPE(predictions,actualValues){let sum=0;for(let i=0,l=predictions?.length;i<l;i++){sum+=Math.abs((actualValues[i]-predictions[i])/actualValues[i])}return sum/predictions?.length*100||null}function isJsonObject(obj){return Object.prototype.toString.call(obj)==="[object Object]"}async function IDBinit(){return await new Promise(resolve=>{let request=indexedDB.open("Kanshi.Anime.Recommendations.Anilist.W~uPtWCq=vG$TR:Zl^#t<vdS]I~N70",1);request.onerror=error=>{console.error(error)};request.onsuccess=event=>{db=event.target.result;return resolve()};request.onupgradeneeded=event=>{db=event.target.result;db.createObjectStore("MyObjectStore");let transaction=event.target.transaction;transaction.oncomplete=()=>{return resolve()}}})}async function saveJSON(data,name){return await new Promise(async(resolve,reject)=>{try{let write=db.transaction("MyObjectStore","readwrite").objectStore("MyObjectStore").openCursor();write.onsuccess=async event=>{let put=await db.transaction("MyObjectStore","readwrite").objectStore("MyObjectStore").put(data,name);put.onsuccess=event=>{return resolve()};put.onerror=event=>{return resolve()}};write.onerror=async error=>{console.error(error);return reject()}}catch(ex){console.error(ex)}})}async function retrieveJSON(name){return await new Promise(resolve=>{try{let read=db.transaction("MyObjectStore","readwrite").objectStore("MyObjectStore").get(name);read.onsuccess=()=>{return resolve(read.result)};read.onerror=error=>{console.error(error);return resolve()}}catch(ex){console.error(ex);return resolve()}})}function getJapaneseStartDate({season,year,month,day}){if(parseInt(year)>=0){if(parseInt(month)>=0){return new Date(parseInt(year),parseInt(month),parseInt(day||1)||1)}const seasonKey=season?.trim()?.toLowerCase?.();if(["winter","spring","summer","fall"].includes(seasonKey)&&!isNaN(year)){let seasons={winter:new Date(parseInt(year),0,1),spring:new Date(parseInt(year),3,1),summer:new Date(parseInt(year),6,1),fall:new Date(parseInt(year),9,1)};return seasons[seasonKey]}return new Date(parseInt(year),0,1)}else{return null}}function ncsCompare(str1,str2){try{if(typeof str1!=="string"||typeof str2!=="string"){return false}return str1.trim().toLowerCase()===str2.trim().toLowerCase()}catch(e){}}let startPost=performance.now();function loadProgress(progress){let endPost=performance.now();if(endPost-startPost>17){self.postMessage({progress:progress});startPost=endPost}}
let db,windowHREF;self.addEventListener("unhandledrejection",event=>{const reason=event?.reason;console.error(reason);let error=reason?.stack||reason?.message;if(typeof error!=="string"||!error){error="Something went wrong"}self.postMessage({error:error})});self.onmessage=async({data})=>{if(!windowHREF&&data?.windowHREF){windowHREF=data.windowHREF}if(!db)await IDBinit();let tagInfo=await retrieveJSON("tagInfo");let tagInfoUpdateAt=await retrieveJSON("tagInfoUpdateAt");if(tagInfoUpdateAt>0&&hasTagInfoData(tagInfo)){const tagInfoUpdateAtDate=new Date(tagInfoUpdateAt*1e3);const currentDate=new Date;const currentYear=currentDate.getFullYear();const seasons={Winter:new Date(parseInt(currentYear),0,1),Spring:new Date(parseInt(currentYear),3,1),Summer:new Date(parseInt(currentYear),6,1),Fall:new Date(parseInt(currentYear),9,1)};let shouldUpdateTagInfo;if(currentDate>=seasons.Winter&&currentDate<seasons.Spring){shouldUpdateTagInfo=tagInfoUpdateAtDate<seasons.Winter}else if(currentDate>=seasons.Spring&&currentDate<seasons.Summer){shouldUpdateTagInfo=tagInfoUpdateAtDate<seasons.Spring}else if(currentDate>=seasons.Summer&&currentDate<seasons.Fall){shouldUpdateTagInfo=tagInfoUpdateAtDate<seasons.Summer}else{shouldUpdateTagInfo=tagInfoUpdateAtDate<seasons.Fall}if(shouldUpdateTagInfo){getTagInfoData(tagInfo)}else{self.postMessage({done:true})}}else{getTagInfoData()}};async function getTagInfoData(tagInfo){try{const response=await fetch("https://graphql.anilist.co",{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({query:`{MediaTagCollection{name category description}}`})});const result=await response?.json?.();const mediaTagCollection=result?.data?.MediaTagCollection||[];for(let i=0,l=mediaTagCollection?.length;i<l;i++){const tagCollected=mediaTagCollection?.[i];const description=tagCollected?.description;let category=tagCollected?.category;let tag=tagCollected?.name;if(typeof tag==="string"&&typeof category!=="string"&&tag&&category){if(!isJsonObject(tagInfo)){tagInfo={};tagInfo[category]={}}else if(!isJsonObject(tagInfo?.[category])){tagInfo[category]={}}if(description&&typeof description==="string"){tagInfo[category][tag]=description}}}if(isJsonObject(tagInfo)&&!jsonIsEmpty(tagInfo)){await saveJSONCollection({tagInfo:tagInfo,tagInfoUpdateAt:parseInt((new Date).getTime()/1e3)})}self.postMessage({done:true})}catch{if(!await isConnected()){self.postMessage({done:true})}else{setTimeout(()=>getTagInfoData(tagInfo),6e4)}}}function hasTagInfoData(tagInfo){for(let category in tagInfo){for(let tag in tagInfo[category]){return typeof tagInfo[category][tag]==="string"}return false}return false}function IDBinit(){return new Promise(resolve=>{let request=indexedDB.open("Kanshi.Media.Recommendations.Anilist.W~uPtWCq=vG$TR:Zl^#t<vdS]I~N70",1);request.onsuccess=event=>{db=event.target.result;resolve()};request.onupgradeneeded=event=>{db=event.target.result;db.createObjectStore("others");event.target.transaction.oncomplete=()=>{resolve()}};request.onerror=error=>{console.error(error)}})}function retrieveJSON(name){return new Promise(resolve=>{try{let get=db.transaction("others","readonly").objectStore("others").get(name);get.onsuccess=()=>{let result=get.result;if(result instanceof Blob){result=JSON.parse((new FileReaderSync).readAsText(result))}else if(result instanceof ArrayBuffer){result=JSON.parse((new TextDecoder).decode(result))}resolve(result)};get.onerror=ex=>{console.error(ex);resolve()}}catch(ex){console.error(ex);resolve()}})}function saveJSONCollection(collection){return new Promise((resolve,reject)=>{try{let transaction=db.transaction("others","readwrite");let store=transaction.objectStore("others");let put;transaction.oncomplete=()=>{resolve()};for(let key in collection){let data=collection[key];let blob;if(data instanceof Blob){blob=data;put=store.put(blob,key)}else if(isJsonObject(data)||data instanceof Array){blob=new Blob([JSON.stringify(data)]);put=store.put(blob,key)}else{put=store.put(data,key)}put.onerror=ex=>{transaction.oncomplete=undefined;if(blob instanceof Blob){try{transaction.oncomplete=()=>{resolve()};put=store.put((new FileReaderSync).readAsArrayBuffer(blob),key);put.onerror=ex=>{console.error(ex);reject(ex)};try{transaction?.commit?.()}catch{}}catch(ex2){console.error(ex);console.error(ex2);reject(ex2)}}else{console.error(ex);reject(ex)}}}try{transaction?.commit?.()}catch{}}catch(ex){console.error(ex);reject(ex)}})}function isJsonObject(obj){return Object.prototype.toString.call(obj)==="[object Object]"}function jsonIsEmpty(obj){for(const key in obj)return false;return true}let isConnectedPromise;async function isConnected(){if(isConnectedPromise)return isConnectedPromise;isConnectedPromise=(async()=>{try{if(navigator?.onLine!==false){if(typeof windowHREF!=="string"||windowHREF===""){return true}let response=await fetch(windowHREF,{method:"HEAD",cache:"no-store"});isConnectedPromise=null;return response?.ok}isConnectedPromise=null;return false}catch(error){isConnectedPromise=null;return false}})();return isConnectedPromise}
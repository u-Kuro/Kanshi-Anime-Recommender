let db;self.addEventListener("unhandledrejection",event=>{const reason=event?.reason;console.error(reason);let error=reason?.stack||reason?.message;if(typeof error!=="string"||!error){error="Something went wrong"}self.postMessage({error:error})});self.onmessage=async({data})=>{if(!db)await IDBInit();const mediaOptions=await getIDBData("mediaOptions");if(isJsonObject(mediaOptions)&&!jsonIsEmpty(mediaOptions)){let orderedMediaOptions={sortFilter:["Weighted Score","Score","Average Score","User Score","Popularity","Trending","Date","Date Updated","Date Added","Favorites"],Season:["Current Season","Next Season","Previous Season","Ongoing Seasons","Future Seasons","Past Seasons","Winter","Spring","Summer","Fall"],"Flexible Inclusion":["OR: Genre","OR: Tag","OR: Studio","OR: Genre / Tag","OR: Genre / Studio","OR: Tag / Studio","OR: Genre / Tag / Studio"],"Shown Metric":["Weighted Score","Score","Average Score","User Score","Popularity","Favorites","Trending"],"Shown List":["Recommended Studio","Non-Caution","Non-Semi-Caution","Non-Disliked-Genres","Non-Disliked-Tags","Recommended Score","Semi-Recommended Score","Other Score"]};const orderedFiltersKeys=["Genre","Tag","Tag Category","Year","Format","Country Of Origin","Release Status","User Status","Studio"];const optionsSort={Year:"descnum",Format:{Special:9,"One Shot":8,ONA:7,OVA:6,"TV Short":5,Movie:4,TV:3,Novel:2,Manga:1,Anime:0},"Country Of Origin":{TW:3,CN:2,KR:1,JP:0}};const algorithmFilterSelections={Genre:1,Tag:1,"Tag Category":1};for(let i=0;i<orderedFiltersKeys.length;i++){const filterKey=orderedFiltersKeys[i],isAlgorithmFilterSelection=algorithmFilterSelections[filterKey];let options=Object.keys(mediaOptions[filterKey]).reduce((uniqueOptions,k)=>{if(!uniqueOptions[k]){uniqueOptions[k]=1}return uniqueOptions},{});if(isAlgorithmFilterSelection){delete options.All;options=Object.keys(options)}else{options=Object.keys(options)}const optionSort=optionsSort[filterKey];if(optionSort==="descnum"){options.sort((a,b)=>parseFloat(b)-parseFloat(a))}else if(isJsonObject(optionSort)){options.sort((a,b)=>{const optionSortA=optionSort[a];const optionSortB=optionSort[b];const isNumberA=typeof optionSortA==="number";const isNumberB=typeof optionSortB==="number";if(isNumberA&&isNumberB){return optionSortA-optionSortB}if(isNumberA){return-1}if(isNumberB){return 1}const isStringA=typeof a==="string";const isStringB=typeof b==="string";if(isStringA&&isStringB){return a.localeCompare(b,undefined,{sensitivity:"base"})}if(isStringA){return-1}if(isStringB){return 1}return 0})}else{options.sort((a,b)=>a.localeCompare(b,undefined,{sensitivity:"base"}))}if(isAlgorithmFilterSelection){options.unshift("All")}orderedMediaOptions[filterKey]=options}orderedMediaOptions=await compressJSONToBlob(orderedMediaOptions);await setIDBData("orderedMediaOptions",orderedMediaOptions);self.postMessage(data?orderedMediaOptions:{done:true})}else{self.postMessage({error:"Filters not found"})}};function IDBInit(){return new Promise((resolve,reject)=>{try{const request=indexedDB.open("Kanshi.Media.Recommendations.AniList.W~uPtWCq=vG$TR:Zl^#t<vdS]I~N70",1);request.onsuccess=({target})=>{db=target.result;resolve()};request.onupgradeneeded=({target})=>{try{const{result,transaction}=target;const stores=["mediaEntries","mediaEntriesInfo","excludedMediaIds","mediaUpdateAt","mediaOptions","orderedMediaOptions","tagInfo","tagInfoUpdateAt","username","userMediaEntries","userMediaUpdateAt","recommendedMediaEntries","algorithmFilters","mediaCautions","hiddenMediaEntries","categories","selectedCategory","autoPlay","gridFullView","showRateLimit","showStatus","autoUpdate","autoExport","runnedAutoUpdateAt","runnedAutoExportAt","exportPathIsAvailable","shouldManageMedia","shouldProcessRecommendedEntries","nearestMediaReleaseAiringAt","recommendationError","visited","others"];for(const store of stores){result.createObjectStore(store)}transaction.oncomplete=()=>{db=result;resolve()}}catch(ex){console.error(ex);reject(ex);transaction.abort()}};request.onerror=ex=>{console.error(ex);reject(ex)}}catch(ex){console.error(ex);reject(ex)}})}function getIDBData(key){return new Promise(resolve=>{try{const get=db.transaction(key,"readonly").objectStore(key).get(key);get.onsuccess=async()=>{let value=get.result;if(value instanceof Blob){value=await new Response(value.stream().pipeThrough(new DecompressionStream("gzip"))).json()}resolve(value)};get.onerror=ex=>{console.error(ex);resolve()}}catch(ex){console.error(ex);resolve()}})}function setIDBData(key,value){return new Promise((resolve,reject)=>{try{const transaction=db.transaction(key,"readwrite");const put=transaction.objectStore(key).put(value,key);put.onerror=ex=>{console.error(ex);reject(ex);transaction.abort()};transaction.oncomplete=()=>resolve()}catch(ex){console.error(ex);reject(ex)}})}function jsonIsEmpty(obj){for(const key in obj){return false}return true}function isJsonObject(obj){return Object.prototype.toString.call(obj)==="[object Object]"}async function compressBlob(blob){return await new Response(blob.stream().pipeThrough(new CompressionStream("gzip"))).blob()}async function compressJSONToBlob(json){return await compressBlob(new Blob([JSON.stringify(json)]))}
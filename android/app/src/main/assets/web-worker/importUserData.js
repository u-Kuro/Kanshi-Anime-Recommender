let request,db;self.addEventListener("unhandledrejection",event=>{const reason=event?.reason;console.error(reason);let error=reason?.stack||reason?.message;if(typeof error!=="string"||!error){error="Something went wrong"}self.postMessage({error:error})});self.onmessage=async({data})=>{if(!db){await IDBInit()}self.postMessage({status:"Importing User Data"});if(data.importedFile instanceof File||data.importedFile instanceof Blob){try{const blobs=await decompressBlobs(data.importedFile);const recordsToSet={};if(blobs.username instanceof Blob&&blobs.userMediaEntries instanceof Blob){blobs.username=await decompressBlobToJSON(blobs.username);if(typeof blobs.username==="string"||blobs.username!==""){if(blobs.userMediaUpdateAt instanceof Blob){blobs.userMediaUpdateAt=await decompressBlobToJSON(blobs.userMediaUpdateAt);if(!isValidDateTime(blobs.userMediaUpdateAt))blobs.userMediaUpdateAt=0}else{blobs.userMediaUpdateAt=0}recordsToSet.username=blobs.username;recordsToSet.userMediaEntries=blobs.userMediaEntries;recordsToSet.userMediaUpdateAt=blobs.userMediaUpdateAt;self.postMessage({username:blobs.username})}}if(blobs.tagInfo instanceof Blob){const tagInfo=await decompressBlobToJSON(blobs.tagInfo);if(isJsonObject(tagInfo)&&!jsonIsEmpty(tagInfo)){if(blobs.tagInfoUpdateAt instanceof Blob){blobs.tagInfoUpdateAt=await decompressBlobToJSON(blobs.tagInfoUpdateAt);if(!isValidDateTime(blobs.tagInfoUpdateAt))blobs.tagInfoUpdateAt=0}else{blobs.tagInfoUpdateAt=0}recordsToSet.tagInfo=blobs.tagInfo;recordsToSet.tagInfoUpdateAt=blobs.tagInfoUpdateAt;self.postMessage(await compressJSONToBlob({tagInfo:tagInfo}))}}if(blobs.algorithmFilters instanceof Blob){const algorithmFilters=await decompressBlobToJSON(blobs.algorithmFilters);if(algorithmFilters instanceof Array&&algorithmFilters.length>0){recordsToSet.algorithmFilters=blobs.algorithmFilters;self.postMessage(await compressJSONToBlob({algorithmFilters:algorithmFilters}))}}if(blobs.categories instanceof Blob){self.postMessage({hasNewCategories:true});if(blobs.mediaCautions instanceof Blob){const mediaCautions=await decompressBlobToJSON(blobs.mediaCautions);if(mediaCautions instanceof Array&&mediaCautions.length>0){recordsToSet.mediaCautions=blobs.mediaCautions;self.postMessage(await compressJSONToBlob({mediaCautions:mediaCautions}))}}if(blobs.hiddenMediaEntries instanceof Blob){const hiddenMediaEntries=await decompressBlobToJSON(blobs.hiddenMediaEntries);if(isJsonObject(hiddenMediaEntries)&&!jsonIsEmpty(hiddenMediaEntries)){recordsToSet.hiddenMediaEntries=blobs.hiddenMediaEntries;self.postMessage(await compressJSONToBlob({hiddenMediaEntries:hiddenMediaEntries}))}}recordsToSet.categories=blobs.categories}if(blobs.mediaEntries instanceof Blob&&blobs.mediaEntriesInfo instanceof Blob&&blobs.excludedMediaIds instanceof Blob){if(blobs.mediaUpdateAt instanceof Blob){blobs.mediaUpdateAt=await decompressBlobToJSON(blobs.mediaUpdateAt);if(!isValidDateTime(blobs.mediaUpdateAt))blobs.mediaUpdateAt=1706674120}else{blobs.mediaUpdateAt=1706674120}recordsToSet.excludedMediaIds=blobs.excludedMediaIds;recordsToSet.mediaEntriesInfo=blobs.mediaEntriesInfo;recordsToSet.mediaEntries=blobs.mediaEntries;recordsToSet.mediaUpdateAt=blobs.mediaUpdateAt}if(!jsonIsEmpty(recordsToSet)){recordsToSet.shouldProcessRecommendedEntries=true;await setIDBRecords(recordsToSet);self.postMessage({status:"Data has been Imported"});self.postMessage({status:null});self.postMessage({progress:100});self.postMessage({message:"success"})}else{self.postMessage({status:"Something went wrong"});self.postMessage({status:null});self.postMessage({progress:100});self.postMessage({error:"Something went wrong"})}}catch(reason){console.error(reason);let error=reason?.stack||reason?.message;if(typeof error!=="string"||!error){error="Failed to retrieve the data"}self.postMessage({error:error})}}else{self.postMessage({error:"Invalid Backup File"})}};function IDBInit(){return new Promise((resolve,reject)=>{try{const request=indexedDB.open("Kanshi.Media.Recommendations.AniList.W~uPtWCq=vG$TR:Zl^#t<vdS]I~N70",1);request.onsuccess=({target})=>{db=target.result;resolve()};request.onupgradeneeded=({target})=>{try{const{result,transaction}=target;const stores=["mediaEntries","mediaEntriesInfo","excludedMediaIds","mediaUpdateAt","mediaOptions","orderedMediaOptions","tagInfo","tagInfoUpdateAt","username","userMediaEntries","userMediaUpdateAt","recommendedMediaEntries","algorithmFilters","mediaCautions","hiddenMediaEntries","categories","selectedCategory","autoPlay","gridFullView","showRateLimit","showStatus","autoUpdate","autoExport","runnedAutoUpdateAt","runnedAutoExportAt","exportPathIsAvailable","shouldManageMedia","shouldProcessRecommendedEntries","nearestMediaReleaseAiringAt","recommendationError","visited","others"];for(const store of stores){result.createObjectStore(store)}transaction.oncomplete=()=>{db=result;resolve()}}catch(ex){console.error(ex);reject(ex);transaction.abort()}};request.onerror=ex=>{console.error(ex);reject(ex)}}catch(ex){console.error(ex);reject(ex)}})}function setIDBRecords(records){return new Promise((resolve,reject)=>{try{const transaction=db.transaction(Object.keys(records),"readwrite");for(const key in records){const put=transaction.objectStore(key).put(records[key],key);put.onerror=ex=>{console.error(ex);reject(ex);transaction.abort()}}transaction.oncomplete=()=>{resolve()}}catch(ex){console.error(ex);reject(ex)}})}async function decompressBlobs(data){const arrayBuffer=await new Response(data.stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer();const dataView=new DataView(arrayBuffer);let offset=0;const numBlobs=dataView.getUint32(offset,true);offset+=4;const result={};for(let i=0;i<numBlobs;i++){const keyLength=dataView.getUint32(offset,true);offset+=4;const key=(new TextDecoder).decode(arrayBuffer.slice(offset,offset+keyLength));offset+=keyLength;const blobLength=dataView.getUint32(offset,true);offset+=4;result[key]=new Blob([arrayBuffer.slice(offset,offset+blobLength)]);offset+=blobLength}return result}async function decompressBlobToJSON(blob){return await new Response(blob.stream().pipeThrough(new DecompressionStream("gzip"))).json()}async function compressBlob(blob){return await new Response(blob.stream().pipeThrough(new CompressionStream("gzip"))).blob()}async function compressJSONToBlob(json){return await compressBlob(new Blob([JSON.stringify(json)]))}function isJsonObject(obj){return Object.prototype.toString.call(obj)==="[object Object]"}function jsonIsEmpty(obj){for(const key in obj){return false}return true}function isValidDateTime(dateTime){return typeof dateTime==="number"&&!isNaN(new Date(dateTime))}
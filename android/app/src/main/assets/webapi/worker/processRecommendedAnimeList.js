let db;const mediaRelationTypes=["source","adaptation","prequel","sequel","parent","side_story","summary","compilation","alternative","spin_off"];const minNumber=1-6e-17!==1?6e-17:Number.EPSILON;self.addEventListener("unhandledrejection",event=>{console.error(event?.reason);self.postMessage({error:event?.reason||"Something went wrong"})});self.onmessage=async({data})=>{try{if(!db)await IDBinit();self.postMessage({status:"Processing Recommendation List"});const animeEntries=await retrieveJSON("animeEntries")||{};const userData=await retrieveJSON("userData");const userEntries=(userData?.userEntries??await retrieveJSON("userEntries"))||[];let includedUserEntryCount;let contentFocused=false,includeUnknownVar=false,measure="mean",includeYear=true,includeAverageScore=false,minPopularity,minAverageScore,minSampleSize,sampleSize,tagRankLimit=minNumber,customUserScoreBase,genresWithLowerCount={};let include={genres:{},tags:{},categories:{}},exclude={genres:{},tags:{},categories:{}};let algorithmFilters=data?.algorithmFilters;const hasNewAlgorithmFilter=algorithmFilters!=null;if(!hasNewAlgorithmFilter){algorithmFilters=await retrieveJSON("algorithmFilters")||[]}algorithmFilters.forEach(({status,filterType,optionName,optionCategory,optionValue})=>{if(status==="included"){if(filterType==="selection"){if(optionCategory==="genre"){include.genres["genre: "+optionName.toLowerCase()]=true}else if(optionCategory==="tag"){include.tags["tag: "+optionName.toLowerCase()]=true}else if(optionCategory==="tag category"){include.categories["tag category: "+optionName.toLowerCase()]=true}else if(optionCategory==="measure"){if(optionName.toLowerCase()==="mode"){measure="mode"}}}else if(filterType==="bool"){if(optionName.toLowerCase()==="content focused"){contentFocused=true}else if(optionName.toLowerCase()==="inc. all factors"){includeUnknownVar=true}else if(optionName.toLowerCase()==="inc. average score"){includeAverageScore=true}else if(optionName.toLowerCase()==="exclude year"){includeYear=false}}else if(filterType==="number"){if(optionName.toLowerCase()==="min tag percentage"){let newTagRankLimit=parseFloat(optionValue);if(newTagRankLimit>0){tagRankLimit=newTagRankLimit}}else if(optionName.toLowerCase()==="scoring system"){customUserScoreBase=parseFloat(optionValue)}else if(optionName.toLowerCase()==="sample size"){sampleSize=parseFloat(optionValue)}else if(optionName.toLowerCase()==="min sample size"){minSampleSize=parseFloat(optionValue)}else if(optionName.toLowerCase()==="min popularity"){minPopularity=parseFloat(optionValue)}else if(optionName.toLowerCase()==="min average score"){minAverageScore=parseFloat(optionValue)}}}else if(status==="excluded"){if(filterType==="selection"){if(optionCategory==="genre"){exclude.genres["genre: "+optionName.toLowerCase()]=true}else if(optionCategory==="tag"){exclude.tags["tag: "+optionName.toLowerCase()]=true}else if(optionCategory==="tag category"){exclude.categories["tag category: "+optionName.toLowerCase()]=true}}}});includedUserEntryCount=0;self.postMessage({status:"Processing Recommendation List"});if(userEntries.length>=2){if(isJsonObject(userEntries[0])&&isJsonObject(userEntries[1])){userEntries.sort((a,b)=>{let x=a?.score!=null?a.score:-Infinity,y=b?.score!=null?b.score:-Infinity;if(x!==y)return y-x;x=a?.media?.popularity!=null?a.media.popularity:-Infinity;y=b?.media?.popularity!=null?b.media.popularity:-Infinity;return y-x})}}let varScheme={genres:{},tags:{},studios:{}};let userEntriesStatus={};let averageScore=[];let year=[];let genresMeanCount={};let tagsMeanCount={};let studiosMeanCount={};let includedAnimeRelations={};self.postMessage({status:"Processing Recommendation List"});for(let i=0,l=userEntries.length;i<l;i++){loadProgress((i+1)/l*100*.3);let anime=userEntries[i].media;let animeID=anime?.id;let status=userEntries[i].status;let userScore=userEntries[i].score;let episodeProgress=userEntries[i].progress;let volumeProgress=userEntries[i].progressVolumes;if(animeID){if(!isJsonObject(userEntriesStatus[animeID])){userEntriesStatus[animeID]={}}if(status&&typeof status==="string"){userEntriesStatus[animeID].userStatus=status}if(userScore>0){userEntriesStatus[animeID].userScore=userScore}if(episodeProgress>0){userEntriesStatus[animeID].episodeProgress=episodeProgress}if(volumeProgress>0){userEntriesStatus[animeID].volumeProgress=volumeProgress}}let genres=anime?.genres||[];let tags=anime?.tags||[];let studios=anime?.studios?.edges?.filter?.(e=>e?.isMain)||[];if(userScore>0){if(includedAnimeRelations[animeID])continue;includedAnimeRelations[animeID]=true;let animeRelations=anime?.relations?.edges||[];if(animeRelations instanceof Array){if(animeRelations.length>0){animeRelations.forEach(e=>{let animeRelationType=e?.relationType;let relationID=e?.node?.id;if(typeof animeRelationType==="string"&&typeof relationID==="number"){if(mediaRelationTypes.includes(animeRelationType.trim().toLowerCase())){includedAnimeRelations[relationID]=true}}})}}++includedUserEntryCount;for(let j=0,jl=genres.length;j<jl;j++){let genre=genres[j];if(typeof genre==="string"){let fullGenre="genre: "+formatCustomString(genre.trim().toLowerCase());if((jsonIsEmpty(include.genres)||include.genres[fullGenre]||include.genres["genre: all"])&&!exclude.genres[fullGenre]&&!exclude.genres["genre: all"]){if(varScheme.genres[fullGenre]){varScheme.genres[fullGenre].userScore.push(userScore);++varScheme.genres[fullGenre].count}else{varScheme.genres[fullGenre]={userScore:[userScore],count:1}}if(genresMeanCount[fullGenre]){++genresMeanCount[fullGenre]}else{genresMeanCount[fullGenre]=1}}}}for(let j=0,jl=tags.length;j<jl;j++){let tagRank=tags[j]?.rank;if(!tagRank||tagRank<tagRankLimit)continue;let tag=tags[j]?.name;let tagCategory=tags[j]?.category;if(typeof tag==="string"&&typeof tagCategory==="string"){let fullTag="tag: "+formatCustomString(tag.trim().toLowerCase());let fullTagCategory="tag category: "+formatCustomString(tagCategory.trim().toLowerCase());if((jsonIsEmpty(include.categories)||include.categories[fullTagCategory]||include.categories["tag category: all"])&&!exclude.categories[fullTagCategory]&&!exclude.categories["tag category: all"]&&(jsonIsEmpty(include.tags)||include.tags[fullTag]||include.tags["tag: all"])&&!exclude.tags[fullTag]&&!exclude.tags["tag: all"]){let tagWeight=tagRank*.01;if(varScheme.tags[fullTag]){varScheme.tags[fullTag].userScore.push(userScore*tagWeight);varScheme.tags[fullTag].count=varScheme.tags[fullTag].count+tagWeight}else{varScheme.tags[fullTag]={userScore:[userScore*tagWeight],count:tagWeight}}if(tagsMeanCount[fullTag]){tagsMeanCount[fullTag]=tagsMeanCount[fullTag]+tagWeight}else{tagsMeanCount[fullTag]=tagWeight}}}}let includedStudios={};for(let j=0,jl=studios.length;j<jl;j++){let studio=studios[j]?.node?.name;if(typeof studio==="string"){if(includedStudios[studio])continue;includedStudios[studio]=true;let fullStudio="studio: "+formatCustomString(studio.trim().toLowerCase());if(varScheme.studios[fullStudio]){varScheme.studios[fullStudio].userScore.push(userScore);++varScheme.studios[fullStudio].count}else{varScheme.studios[fullStudio]={userScore:[userScore],count:1}}if(studiosMeanCount[fullStudio]){++studiosMeanCount[fullStudio]}else{studiosMeanCount[fullStudio]=1}}}if(isaN(anime?.averageScore)&&includeAverageScore){averageScore.push({userScore:userScore,averageScore:anime.averageScore})}let animeYear=anime?.seasonYear||anime?.startDate?.year||anime?.endDate?.year;if(isaN(parseFloat(animeYear))&&includeYear){year.push({userScore:userScore,year:parseFloat(animeYear)})}}}if(includedUserEntryCount<1){varScheme={}}else{let genresMeanCountHigher;if(typeof sampleSize==="number"&&sampleSize>=1){genresMeanCount=sampleSize}else if(!jsonIsEmpty(genresMeanCount)){let genresCountValues=Object.values(genresMeanCount);genresCountValues=filterArrayByMeanPercentages(genresCountValues);genresMeanCount=Math.max(arrayMean(genresCountValues),arrayMode(genresCountValues));let genresMeanCountHigherValues=genresCountValues.filter(count=>count>genresMeanCount);genresMeanCountHigher=Math.max(arrayMean(genresMeanCountHigherValues),arrayMode(genresMeanCountHigherValues))}else{genresMeanCount=10}if(minSampleSize>=0){genresMeanCount=Math.max(minSampleSize,genresMeanCount)}if(typeof sampleSize==="number"&&sampleSize>=1){tagsMeanCount=sampleSize}else if(!jsonIsEmpty(tagsMeanCount)){let tagsCountValues=Object.values(tagsMeanCount);tagsCountValues=filterArrayByMeanPercentages(tagsCountValues);tagsMeanCount=Math.max(arrayMean(tagsCountValues),arrayMode(tagsCountValues))}else{tagsMeanCount=10}if(minSampleSize>=0){tagsMeanCount=Math.max(minSampleSize,tagsMeanCount)}if(typeof sampleSize==="number"&&sampleSize>=1){studiosMeanCount=sampleSize}else if(!jsonIsEmpty(studiosMeanCount)){let studiosCountValues=Object.values(studiosMeanCount);studiosMeanCount=arrayMode(studiosCountValues)}else{studiosMeanCount=10}if(minSampleSize>=0){studiosMeanCount=Math.max(minSampleSize,studiosMeanCount)}varScheme.includeUnknownVar=!contentFocused&&includeUnknownVar;varScheme.minPopularity=minPopularity;varScheme.minAverageScore=minAverageScore;let genresKey=Object.keys(varScheme.genres);let genresMean=[];for(let i=0,l=genresKey.length;i<l;i++){if(measure==="mode"){let tempModeScore=arrayMode(varScheme.genres[genresKey[i]].userScore);genresMean.push(tempModeScore)}else{let tempMeanScore=arrayMean(varScheme.genres[genresKey[i]].userScore);genresMean.push(tempMeanScore)}}genresMean=Math.max(arrayMean(genresMean),arrayMode(genresMean));for(let i=0,l=genresKey.length;i<l;i++){let originalScore;if(measure==="mode"){originalScore=arrayMode(varScheme.genres[genresKey[i]].userScore)}else{originalScore=arrayMean(varScheme.genres[genresKey[i]].userScore)}let count=varScheme.genres[genresKey[i]].count;let score=originalScore;if(count<genresMeanCountHigher){genresWithLowerCount[genresKey[i]]=true}if(contentFocused||count<genresMeanCount||count<genresMeanCountHigher&&originalScore<genresMean){if(contentFocused||count<genresMeanCount){let Cweight=count/genresMeanCount;score=score*Cweight}if(contentFocused||originalScore<genresMean){let Sweight=originalScore/genresMean;score=score*Sweight}}varScheme.genres[genresKey[i]]=score}let tagsKey=Object.keys(varScheme.tags);let tagsMean=[];for(let i=0,l=tagsKey.length;i<l;i++){if(measure==="mode"){let tempModeScore=arrayMode(varScheme.tags[tagsKey[i]].userScore);tagsMean.push(tempModeScore)}else{let tempMeanScore=arrayMean(varScheme.tags[tagsKey[i]].userScore);tagsMean.push(tempMeanScore)}}tagsMean=Math.max(arrayMean(tagsMean),arrayMode(tagsMean));let tempTags={};for(let i=0;i<tagsKey.length;i++){let originalScore;if(measure==="mode"){originalScore=arrayMode(varScheme.tags[tagsKey[i]].userScore)}else{originalScore=arrayMean(varScheme.tags[tagsKey[i]].userScore)}let count=varScheme.tags[tagsKey[i]].count;let score=originalScore;if(contentFocused||count<tagsMeanCount||originalScore<tagsMean){if(contentFocused||count<tagsMeanCount){let Cweight=count/tagsMeanCount;score=score*Cweight}if(contentFocused||originalScore<tagsMean){let Sweight=originalScore/tagsMean;score=score*Sweight}}varScheme.tags[tagsKey[i]]=score;tempTags[tagsKey[i]]={score:score,count:count}}let studiosKey=Object.keys(varScheme.studios);let studiosMean=[];for(let i=0,l=studiosKey.length;i<l;i++){if(measure==="mode"){let tempModeScore=arrayMode(varScheme.studios[studiosKey[i]].userScore);studiosMean.push(tempModeScore)}else{let tempMeanScore=arrayMean(varScheme.studios[studiosKey[i]].userScore);studiosMean.push(tempMeanScore)}}studiosMean=arrayMean(studiosMean);for(let i=0,l=studiosKey.length;i<l;i++){let originalScore=0;if(measure==="mode"){originalScore=arrayMode(varScheme.studios[studiosKey[i]].userScore)}else{originalScore=arrayMean(varScheme.studios[studiosKey[i]].userScore)}let count=varScheme.studios[studiosKey[i]].count;if(count>=studiosMeanCount&&originalScore>=studiosMean){varScheme.studios[studiosKey[i]]=originalScore}else{delete varScheme.studios[studiosKey[i]]}}varScheme.meanGenres=genresMean;varScheme.meanTags=tagsMean;varScheme.includeCategories=include.categories;varScheme.excludeCategories=exclude.categories;varScheme.includeGenres=include.genres;varScheme.excludeGenres=exclude.genres;varScheme.includeTags=include.tags;varScheme.excludeTags=exclude.tags;if(includeYear){let yearXY=[];for(let i=0,l=year.length;i<l;i++){yearXY.push([year[i].year,year[i].userScore])}if(yearXY.length>=(minSampleSize||33)){varScheme.yearModel=linearRegression(yearXY)}}if(includeAverageScore){let averageScoreXY=[];for(let i=0,l=averageScore.length;i<l;i++){averageScoreXY.push([averageScore[i].averageScore,averageScore[i].userScore])}if(averageScoreXY.length>=(minSampleSize||33)){varScheme.averageScoreModel=linearRegression(averageScoreXY)}}}self.postMessage({status:"Processing Recommendation List"});let recommendedAnimeListArray=[];let userScoreBase=100,maxScore;let meanUserScore,meanScoreAll,meanScoreAbove;let hasAnimeQuality=false;let animeEntriesArray=Object.values(animeEntries??{});let averageScoresArray=[],popularityArray=[];for(let i=0,l=animeEntriesArray.length;i<l;i++){let anime=animeEntriesArray[i];let averageScore=anime.averageScore;if(averageScore>=1){averageScoresArray.push(averageScore)}let popularity=anime.popularity;if(popularity>=1){popularityArray.push(popularity)}}let popularityMode=varScheme?.minPopularity?varScheme.minPopularity:arrayMode(popularityArray);let averageScoreMode=varScheme?.minAverageScore?varScheme.minAverageScore:arrayMode(averageScoresArray);let dayInMillis=1e3*60*60*24;self.postMessage({popularityMode:popularityMode,averageScoreMode:averageScoreMode});let filters=await retrieveJSON("filters");if(!jsonIsEmpty(varScheme)){let userScores=Object.values(userEntriesStatus).map(entry=>entry.userScore);if(userScores?.length){let max=getMax(userScores);userScoreBase=max<=3?3:max<=5?5:max<=10?10:100;meanUserScore=arrayMean(userScores)}for(let i=0,l=animeEntriesArray.length;i<l;i++){loadProgress(i/l*100*.7+30);let anime=animeEntriesArray[i];let animeID=anime?.id;let animeUrl=anime?.siteUrl;let format=anime?.format;let countryOfOrigin=anime?.countryOfOrigin;let year=anime?.seasonYear||anime?.startDate?.year||anime?.endDate?.year;let season=anime?.season;let genres=anime?.genres||[];let tags=anime?.tags||[];let studios=anime?.studios?.edges?.filter?.(e=>e?.isMain)||[];let status=anime?.status;let popularity=anime?.popularity;let userStatus="UNWATCHED";if(typeof userEntriesStatus?.[animeID]?.userStatus==="string"){userStatus=userEntriesStatus?.[animeID]?.userStatus;let tmpUserStatus=userStatus.trim().toLowerCase();if(tmpUserStatus&&filters?.["user status"]&&filters?.["user status"]?.[tmpUserStatus]===undefined){filters["user status"][tmpUserStatus]=true}}if(typeof status==="string"){let tempStatus=status.trim().toLowerCase();if(tempStatus&&filters?.["airing status"]&&filters?.["airing status"]?.[tempStatus]===undefined){filters["airing status"][tempStatus]=true}}if(typeof format==="string"){let tempFormat=format.trim().toLowerCase();if(tempFormat&&filters?.format&&filters?.format?.[tempFormat]===undefined){filters.format[tempFormat]=true}}if(typeof countryOfOrigin==="string"){let tempCountryOfOrigin=countryOfOrigin.trim().toLowerCase();if(tempCountryOfOrigin&&filters?.["country of origin"]&&filters?.["country of origin"]?.[tempCountryOfOrigin]===undefined){filters["country of origin"][tempCountryOfOrigin]=true}}if(year){let tempYear=year?.toString?.().trim().toLowerCase();if(tempYear&&filters?.year&&filters?.year?.[tempYear]===undefined){filters.year[tempYear]=true}}let genresIncluded={};let tagsIncluded={};let studiosIncluded={};let zgenres=[];for(let j=0,jl=genres.length;j<jl;j++){let genre=genres[j];if(typeof genre!=="string")continue;genre=formatCustomString(genre.trim().toLowerCase());let fullGenre="genre: "+genre;if((jsonIsEmpty(varScheme.includeGenres)||varScheme.includeGenres[fullGenre]||varScheme.includeGenres["genre: all"])&&!varScheme.excludeGenres[fullGenre]&&!varScheme.excludeGenres["genre: all"]){if(typeof varScheme.genres[fullGenre]==="number"){zgenres.push({genre:fullGenre,score:varScheme.genres[fullGenre]});if((isJsonObject(genresWithLowerCount)&&!jsonIsEmpty(genresWithLowerCount)&&genresWithLowerCount?.[fullGenre]===undefined||typeof varScheme.meanGenres==="number"&&varScheme.genres[fullGenre]>=varScheme.meanGenres)&&!genresIncluded[genre]){let tmpscore=varScheme.genres[fullGenre];genresIncluded[genre]=tmpscore}}else if(typeof varScheme.meanGenres==="number"&&varScheme.includeUnknownVar){zgenres.push({genre:fullGenre,score:varScheme.meanGenres})}}if(genre&&filters?.genre&&filters?.genre?.[genre]===undefined){filters.genre[genre]=true}}let ztags=[];for(let j=0,jl=tags.length;j<jl;j++){let tag=tags[j]?.name;if(typeof tag!=="string")continue;let tagCategory=tags[j]?.category;if(typeof tagCategory!=="string")continue;let tagRank=tags[j]?.rank;tag=formatCustomString(tag.trim().toLowerCase());let fullTag="tag: "+tag;tagCategory=formatCustomString(tagCategory.trim().toLowerCase());let fullTagCategory="tag category: "+tagCategory;if((jsonIsEmpty(varScheme.includeCategories)||varScheme.includeCategories[fullTagCategory]||varScheme.includeCategories["tag category: all"])&&!varScheme.excludeCategories[fullTagCategory]&&!varScheme.excludeCategories["tag category: all"]&&(jsonIsEmpty(varScheme.includeTags)||varScheme.includeTags[fullTag]||varScheme.includeTags["tag: all"])&&!varScheme.excludeTags[fullTag]&&!varScheme.excludeTags["tag: all"]){if(typeof varScheme.tags[fullTag]==="number"&&typeof tagRank==="number"){if(tagRank&&tagRank>=tagRankLimit){let tagWeight=tagRank*.01;ztags.push(varScheme.tags[fullTag]*tagWeight)}if(typeof varScheme.meanTags==="number"&&varScheme.tags[fullTag]>=varScheme.meanTags&&!tagsIncluded[tag]){let tmpscore=varScheme.tags[fullTag];tagsIncluded[tag]=tmpscore}}else if(typeof varScheme.meanTags==="number"&&varScheme.includeUnknownVar){ztags.push(varScheme.meanTags)}}if(tag&&filters?.tag&&filters?.tag?.[tag]===undefined){filters.tag[tag]=true}if(tagCategory&&filters?.["tag category"]&&filters?.["tag category"]?.[tagCategory]===undefined){filters["tag category"][tagCategory]=true}}let includedStudios={};for(let j=0,jl=studios.length;j<jl;j++){let studio=studios[j]?.node?.name;if(typeof studio!=="string")continue;if(includedStudios[studio])continue;includedStudios[studio]=true;studio=formatCustomString(studio.trim().toLowerCase());let fullStudio="studio: "+studio;if(typeof varScheme.studios[fullStudio]==="number"){if(!studiosIncluded[studio]){let tmpscore=varScheme.studios[fullStudio];studiosIncluded[studio]=tmpscore}}if(studio&&filters?.studio&&filters?.studio?.[studio]===undefined){filters.studio[studio]=true}}let animeQuality=[];let yearModel=varScheme.yearModel??{};if(isaN(year)&&!jsonIsEmpty(yearModel)&&includeYear&&yearModel?.slope>0){let seasonYear=year;if(typeof seasonYear==="string"){seasonYear=parseFloat(seasonYear)}let modelScore=LRpredict(yearModel,seasonYear);if(modelScore>=1){animeQuality.push(modelScore)}else{animeQuality.push(1)}}else{animeQuality.push(1)}let averageScore=anime?.averageScore;let averageScoreModel=varScheme.averageScoreModel??{};if(isaN(averageScore)&&!jsonIsEmpty(averageScoreModel)&&includeAverageScore&&averageScoreModel?.slope>0){if(typeof averageScore==="string"){averageScore=parseFloat(averageScore)}let modelScore=LRpredict(averageScoreModel,averageScore);if(modelScore>=1){animeQuality.push(modelScore)}else{animeQuality.push(1)}}else{animeQuality.push(1)}let episodes=anime?.episodes;let duration=anime?.duration;let animeContent=[];if(zgenres.length){let genreValues=zgenres.reduce((acc,_genre)=>{acc.push(_genre.score);return acc},[]);if(zgenres.some(e=>genresWithLowerCount[e.genre])){if(measure==="mode"){animeContent.push(arrayMode(genreValues))}else{animeContent.push(arrayMean(genreValues))}}else{animeContent.push(getMax(genreValues))}}else{animeContent.push(1)}if(ztags.length){if(measure==="mode"){animeContent.push(arrayMode(ztags))}else{animeContent.push(arrayMean(ztags))}}else{animeContent.push(1)}let finalAnimeQuality=animeQuality.length?measure==="mode"?arrayMode(animeQuality):arrayMean(animeQuality):1;let finalAnimeContent=animeContent.length?measure==="mode"?arrayMode(animeContent):arrayMean(animeContent):1;let score=finalAnimeContent*finalAnimeQuality;if(hasAnimeQuality!==true){if(finalAnimeQuality>0){maxScore=Math.pow(userScoreBase,2);hasAnimeQuality=true}else if(hasAnimeQuality===undefined){maxScore=userScoreBase}}genres=genres.length?genres:[];tags=tags.length?tags.map(e=>{return{name:e?.name,rank:e?.rank}}):[];studios=studios.reduce((result,e)=>Object.assign(result,{[formatCustomString(e?.node?.name)]:e?.node?.siteUrl}),{});let weightedScore;if(averageScore>0){if(score>0&&averageScore<averageScoreMode){let ASweight=averageScore/averageScoreMode;weightedScore=score*ASweight}else{weightedScore=score}}let newScore=weightedScore!==score?weightedScore:score;if(popularity>0&&popularityMode>0){if(newScore>0&&popularity<popularityMode){let PSweight=popularity/popularityMode;weightedScore=score*PSweight}else{weightedScore=newScore}}if(!weightedScore||weightedScore<=0||!isFinite(weightedScore)){weightedScore=1}if(!score||score<=0||!isFinite(score)){score=1}if(typeof anime?.nextAiringEpisode?.episode==="number"&&!isNaN(anime?.nextAiringEpisode?.episode)&&typeof anime?.nextAiringEpisode?.airingAt==="number"&&!isNaN(anime?.nextAiringEpisode?.airingAt)){let airingAt=anime?.nextAiringEpisode?.airingAt;if(anime?.nextAiringEpisode?.episode===episodes){let airingAtDate=new Date(airingAt*1e3);let currentDate=new Date;if(airingAtDate<=currentDate){anime.nextAiringEpisode=null;status="FINISHED"}else if(airingAtDate>currentDate){self.postMessage({animeCompletionAiringAt:anime?.nextAiringEpisode?.airingAt})}}if(isJsonObject(anime.nextAiringEpisode)){let _releaseDateMillis=airingAt*1e3;if((!equalsNCS(userStatus,"UNWATCHED")||weightedScore>1)&&typeof _releaseDateMillis==="number"&&_releaseDateMillis>=(new Date).getTime()-dayInMillis){let _title=anime?.title?.english||anime?.title?.userPreferred||anime?.title?.romaji||anime?.title?.native;let _releaseEpisode=anime?.nextAiringEpisode?.episode;let _imageURL=anime?.coverImage?.large||"";let _episodeProgress=userEntriesStatus?.[animeID]?.episodeProgress||0;self.postMessage({animeReleaseNotification:{id:animeID,title:typeof _title==="string"?_title:"",releaseEpisodes:_releaseEpisode,maxEpisode:typeof episodes==="number"?episodes:-1,releaseDateMillis:_releaseDateMillis,userStatus:typeof userStatus==="string"?userStatus:"UNWATCHED",imageURL:typeof _imageURL==="string"?_imageURL:"",animeUrl:typeof animeUrl==="string"?animeUrl:"",episodeProgress:typeof _episodeProgress==="number"?_episodeProgress:0}})}}}else if(jsonIsEmpty(anime.nextAiringEpisode)&&!(ncsCompare(status,"finished")||ncsCompare(status,"cancelled"))&&year){let{month,day}=anime?.startDate||{};if(parseInt(month)>0){month=parseInt(month)-1}let possibleAiringDate=getJapaneseStartDate({season:season,year:year,month:month,day:day});if(possibleAiringDate&&possibleAiringDate>new Date){anime.nextAiringEpisode={airingAt:Math.floor(possibleAiringDate.getTime()/1e3),episode:1}}}let favoriteContents={genres:genresIncluded,tags:tagsIncluded,studios:studiosIncluded};recommendedAnimeListArray.push({id:animeID,title:anime?.title,animeUrl:animeUrl,userScore:userEntriesStatus?.[animeID]?.userScore,animeRelations:anime?.relations?.edges,averageScore:averageScore,popularity:popularity,trending:anime?.trending,favorites:anime?.favourites,score:score,weightedScore:weightedScore,favoriteContents:favoriteContents,userStatus:formatCustomString(userStatus),status:formatCustomString(status),description:anime?.description,genres:genres.map(e=>formatCustomString(e)),tags:tags.map(e=>formatCustomString(e)),dateAdded:anime?.dateAdded,dateEdited:anime?.dateEdited,startDate:anime?.startDate,year:year,season:formatCustomString(season),format:formatCustomString(format),studios:studios,episodes:episodes,episodeProgress:userEntriesStatus?.[animeID]?.episodeProgress,volumeProgress:userEntriesStatus?.[animeID]?.volumeProgress,duration:duration,chapters:anime?.chapters,volumes:anime?.volumes,countryOfOrigin:formatCustomString(countryOfOrigin),coverImageUrl:anime?.coverImage?.large,trailerID:anime?.trailer?.id,bannerImageUrl:anime?.bannerImage,trailerThumbnailUrl:anime?.trailer?.thumbnail,nextAiringEpisode:anime?.nextAiringEpisode})}}else{for(let i=0,l=animeEntriesArray.length;i<l;i++){loadProgress(i/l*100);let anime=animeEntriesArray[i];let animeID=anime?.id;let animeUrl=anime?.siteUrl;let format=anime?.format;let countryOfOrigin=anime?.countryOfOrigin;let year=anime?.seasonYear||anime?.startDate?.year||anime?.endDate?.year;let season=anime?.season;let genres=anime?.genres||[];let tags=anime?.tags||[];let studios=anime?.studios?.edges?.filter?.(e=>e?.isMain)||[];let status=anime?.status;let episodes=anime?.episodes;let duration=anime?.duration;if(typeof status==="string"){let tempStatus=status.trim().toLowerCase();if(tempStatus&&filters?.["airing status"]&&filters?.["airing status"]?.[tempStatus]===undefined){filters["airing status"][tempStatus]=true}}if(typeof format==="string"){let tempFormat=format.trim().toLowerCase();if(tempFormat&&filters?.format&&filters?.format?.[tempFormat]===undefined){filters.format[tempFormat]=true}}if(typeof countryOfOrigin==="string"){let tempCountryOfOrigin=countryOfOrigin.trim().toLowerCase();if(tempCountryOfOrigin&&filters?.["country of origin"]&&filters?.["country of origin"]?.[tempCountryOfOrigin]===undefined){filters["country of origin"][tempCountryOfOrigin]=true}}if(year){let tempYear=year?.toString?.().trim().toLowerCase();if(tempYear&&filters?.year&&filters?.year?.[tempYear]===undefined){filters.year[tempYear]=true}}for(let j=0,jl=genres.length;j<jl;j++){let genre=genres[j];if(typeof genre!=="string")continue;genre=genre.trim().toLowerCase();if(genre&&filters?.genre&&filters?.genre?.[genre]===undefined){filters.genre[genre]=true}}for(let j=0,jl=tags.length;j<jl;j++){let tag=tags[j]?.name;if(typeof tag!=="string")continue;tag=tag.trim().toLowerCase();if(tag&&filters?.tag&&filters?.tag?.[tag]===undefined){filters.tag[tag]=true}let tagCategory=tags[j]?.category;if(typeof tagCategory!=="string")continue;tagCategory=tagCategory.trim().toLowerCase();if(tagCategory&&filters?.["tag category"]&&filters?.["tag category"]?.[tagCategory]===undefined){filters["tag category"][tagCategory]=true}}for(let j=0,jl=studios.length;j<jl;j++){let studio=studios[j]?.node?.name;if(typeof studio!=="string")continue;studio=studio.trim().toLowerCase();if(studio&&filters?.studio&&filters?.studio?.[studio]===undefined){filters.studio[studio]=true}}let score=minNumber;let averageScore=anime?.averageScore;if(isaN(averageScore)){if(typeof averageScore==="string"){averageScore=parseFloat(averageScore)}}let favourites=anime?.favourites;if(isaN(favourites)){if(typeof favourites==="string"){favourites=parseFloat(favourites)}}let popularity=anime?.popularity;if(isaN(popularity)){if(typeof popularity==="string"){popularity=parseFloat(popularity)}}if(averageScore>0&&favourites>0&&popularity>0&&isaN(averageScore)&&isaN(favourites)&&isaN(popularity)){let favPopRatio=Math.min(favourites,popularity)/popularity;score=favPopRatio*averageScore}maxScore=100;genres=genres.length?genres:[];tags=tags.length?tags.map(e=>{return{name:e?.name,rank:e?.rank}}):[];studios=studios.reduce((result,e)=>Object.assign(result,{[formatCustomString(e?.node?.name)]:e?.node?.siteUrl}),{});let weightedScore;if(averageScore>0){if(score>0&&averageScore<averageScoreMode){let ASweight=averageScore/averageScoreMode;weightedScore=score*ASweight}else{weightedScore=score}}let newScore=weightedScore!==score?weightedScore:score;if(popularity>0&&popularityMode>0){if(newScore>0&&popularity<popularityMode){let PSweight=popularity/popularityMode;weightedScore=score*PSweight}else{weightedScore=newScore}}if(!weightedScore||weightedScore<=0||!isFinite(weightedScore)){weightedScore=1}if(!score||score<=0||!isFinite(score)){score=1}if(typeof anime?.nextAiringEpisode?.episode==="number"&&!isNaN(anime?.nextAiringEpisode?.episode)&&typeof anime?.nextAiringEpisode?.airingAt==="number"&&!isNaN(anime?.nextAiringEpisode?.airingAt)){let airingAt=anime?.nextAiringEpisode?.airingAt;if(anime?.nextAiringEpisode?.episode===episodes){let airingAtDate=new Date(airingAt*1e3);let currentDate=new Date;if(airingAtDate<=currentDate){anime.nextAiringEpisode=null;status="FINISHED"}else if(airingAtDate>currentDate){self.postMessage({animeCompletionAiringAt:anime?.nextAiringEpisode?.airingAt})}}if(isJsonObject(anime.nextAiringEpisode)){let _releaseDateMillis=airingAt*1e3;if(weightedScore>1&&typeof _releaseDateMillis==="number"&&_releaseDateMillis>=(new Date).getTime()-dayInMillis){let _title=anime?.title?.english||anime?.title?.userPreferred||anime?.title?.romaji||anime?.title?.native;let _releaseEpisode=anime?.nextAiringEpisode?.episode;let _imageURL=anime?.coverImage?.large||"";self.postMessage({animeReleaseNotification:{id:animeID,title:typeof _title==="string"?_title:"",releaseEpisodes:_releaseEpisode,maxEpisode:typeof episodes==="number"?episodes:-1,releaseDateMillis:_releaseDateMillis,userStatus:"UNWATCHED",imageURL:typeof _imageURL==="string"?_imageURL:"",animeUrl:typeof animeUrl==="string"?animeUrl:"",episodeProgress:0}})}}}else if(jsonIsEmpty(anime.nextAiringEpisode)&&!(ncsCompare(status,"finished")||ncsCompare(status,"cancelled"))&&year){let{month,day}=anime?.startDate||{};if(parseInt(month)>0){month=parseInt(month)-1}let possibleAiringDate=getJapaneseStartDate({season:season,year:year,month:month,day:day});if(possibleAiringDate&&possibleAiringDate>new Date){anime.nextAiringEpisode={airingAt:Math.floor(possibleAiringDate.getTime()/1e3),episode:1}}}recommendedAnimeListArray.push({id:animeID,title:anime?.title,animeUrl:animeUrl,animeRelations:anime?.relations?.edges,averageScore:averageScore,popularity:popularity,trending:anime?.trending,favorites:anime?.favourites,score:score,weightedScore:weightedScore,userStatus:"UNWATCHED",status:formatCustomString(status),description:anime?.description,genres:genres.map(e=>formatCustomString(e)),tags:tags.map(e=>formatCustomString(e)),dateAdded:anime?.dateAdded,dateEdited:anime?.dateEdited,startDate:anime?.startDate,year:year,season:formatCustomString(season),format:formatCustomString(format),studios:studios,episodes:episodes,duration:duration,chapters:anime?.chapters,volumes:anime?.volumes,countryOfOrigin:formatCustomString(countryOfOrigin),coverImageUrl:anime?.coverImage?.large,trailerID:anime?.trailer?.id,bannerImageUrl:anime?.bannerImage,trailerThumbnailUrl:anime?.trailer?.thumbnail,nextAiringEpisode:anime?.nextAiringEpisode})}}let userAnimeScores=[],userAnimeUserScores=[];let userScoresAnimes=[],scoresArray=[],scoreAboveMeanArray=[];recommendedAnimeListArray=recommendedAnimeListArray.map(anime=>{let originalHighestRange,originalScore;if(customUserScoreBase>=0){originalHighestRange=userScoreBase;originalScore=originalHighestRange>1?mapValue(anime.score,1,maxScore,1,originalHighestRange):anime.score}let newHighestRange=customUserScoreBase>=0?customUserScoreBase:userScoreBase;anime.score=newHighestRange>1?mapValue(anime.score,1,maxScore,1,newHighestRange):anime.score;anime.weightedScore=newHighestRange>1?mapValue(anime.weightedScore,1,maxScore,1,newHighestRange):anime.weightedScore;if(anime.userScore!=null&&anime.userScore>=1){if(anime.userScore>=meanUserScore){scoreAboveMeanArray.push(anime.score)}userScoresAnimes.push(anime);userAnimeScores.push(originalScore===undefined?anime.score:originalScore||anime.score);userAnimeUserScores.push(anime.userScore)}scoresArray.push(anime.score);return anime});if(scoresArray?.length){meanScoreAll=arrayMean(scoresArray)}if(scoreAboveMeanArray?.length){meanScoreAbove=arrayMean(scoreAboveMeanArray)}let recommendedAnimeList={};for(let i=0,l=recommendedAnimeListArray.length;i<l;i++){let anime=recommendedAnimeListArray[i];let animeID=anime.id;anime.meanScoreAll=meanScoreAll>=1?meanScoreAll:1;anime.meanScoreAbove=meanScoreAbove>=1?meanScoreAbove:1;recommendedAnimeList[animeID]=anime}if(hasNewAlgorithmFilter){await saveJSON(algorithmFilters,"algorithmFilters")}await saveJSON(recommendedAnimeList||{},"recommendedAnimeList");await saveJSON(filters,"filters");let recListMAE=calculateMAE(userAnimeUserScores,userAnimeScores);if(recListMAE!=null){await saveJSON(recListMAE,"recListMAE");self.postMessage({recListMAE:recListMAE})}await saveJSON(true,"shouldLoadAnime");await saveJSON(false,"shouldProcessRecommendation");self.postMessage({status:null});self.postMessage({progress:100});self.postMessage({message:"success",hasPassedFilters:data?.hasPassedFilters})}catch(err){console.error(err);self.postMessage({error:err||"Something went wrong"})}};function formatCustomString(str){if(typeof str==="string"){str=str!=="_"?str.replace(/\_/g," "):str;str=str!=='\\"'?str.replace(/\\"/g,'"'):str;str=str.replace(/\b(tv|ona|ova)\b/gi,match=>match.toUpperCase())}return str}function jsonIsEmpty(obj){for(const key in obj){return false}return true}function equalsNCS(str1,str2){let s1=str1;let s2=str2;if(typeof s1==="number")s1=s1.toString();if(typeof s2==="number")s2=s2.toString();if(typeof s1==="string")s1=s1.trim().toLowerCase();if(typeof s2==="string")s2=s2.trim().toLowerCase();return s1===s2}function isaN(num){if(!num&&num!==0){return false}else if(typeof num==="boolean"){return false}else if(typeof num==="string"&&!num){return false}return!isNaN(num)}function isJson(j){try{return j?.constructor.name==="Object"&&`${j}`==="[object Object]"}catch(e){return false}}function mapValue(originalValue,lowestValue,highestValue,newLowestRange,newHighestRange){let mappedValue=(originalValue-lowestValue)*(newHighestRange-newLowestRange)/(highestValue-lowestValue)+newLowestRange;return mappedValue}function arrayMean(obj){return arraySum(obj)/obj.length||0}function arraySum(obj){return obj.reduce((a,b)=>a+b,0)}function arrayMedian(arr){const sortedArr=arr.slice().sort((a,b)=>a-b);const n=sortedArr.length;if(n%2===0){const middleRight=n/2;const middleLeft=middleRight-1;return(sortedArr[middleLeft]+sortedArr[middleRight])/2}else{const middle=Math.floor(n/2);return sortedArr[middle]}}function arrayMode(obj){if(obj.length===0){return}else if(obj.length===1){return obj[0]}else if(obj.length===2){return(obj[0]+obj[1])/2}let max=parseFloat(getMax(obj));let min=parseFloat(getMin(obj));const boundary=minNumber;let classW=parseFloat((max-min)/(1+3.322*Math.log(obj.length)));let classIs=[];if(max===min||classW<boundary){classIs=[{low:min,high:max,freq:0}]}else{let high=min+classW-boundary,low=min;classIs=[{low:low,high:high,freq:0}];while(classIs.slice(-1)[0].high<max){low=high+boundary;high=low+classW-boundary;classIs.push({low:low,high:high,freq:0})}}for(let i=0,l=obj.length;i<l;i++){for(let j=0,jl=classIs.length;j<jl;j++){let num=obj[i];if(num>=classIs[j].low&&num<=classIs[j].high){++classIs[j].freq;continue}}}let modeClass=classIs[0];let modeIdx=0;for(let i=1,l=classIs.length;i<l;i++){if(classIs[i].freq>modeClass.freq){modeClass=classIs[i];modeIdx=i}}let modLowLim=modeClass.low;let modFreq=modeClass.freq;let modPreFreq=!classIs[modeIdx-1]?0:classIs[modeIdx-1].freq;let modSucFreq=!classIs[modeIdx+1]?0:classIs[modeIdx+1].freq;return modLowLim+(modFreq-modPreFreq)/(2*modFreq-modPreFreq-modSucFreq)*classW}function arrayProbability(obj){if(!obj?.length)return 0;return obj.reduce((a,b)=>a*b,1)}function getMax(arr){let len=arr.length;let max=-Infinity;while(len--){max=arr[len]>max?arr[len]:max}return max}function getMin(arr){let len=arr.length;let min=Infinity;while(len--){min=arr[len]<min?arr[len]:min}return min}function filterArrayByMeanPercentages(numbers){const counts={};numbers.forEach(num=>{counts[num]=counts[num]?counts[num]+1:1});const percentages={};Object.keys(counts).forEach(key=>{percentages[key]=counts[key]/numbers.length});const CTPercentage=arrayMean(Object.values(percentages));return numbers.filter(num=>{return percentages[num]<=CTPercentage})}function linearRegression(XY){let lr={};let n=XY.length;let sum_x=0;let sum_y=0;let sum_xy=0;let sum_xx=0;let sum_yy=0;for(let i=0,l=XY.length;i<l;i++){sum_x+=XY[i][0];sum_y+=XY[i][1];sum_xy+=XY[i][0]*XY[i][1];sum_xx+=XY[i][0]*XY[i][0];sum_yy+=XY[i][1]*XY[i][1]}lr["slope"]=(n*sum_xy-sum_x*sum_y)/(n*sum_xx-sum_x*sum_x);lr["intercept"]=(sum_y-lr.slope*sum_x)/n;lr["r2"]=Math.pow((n*sum_xy-sum_x*sum_y)/Math.sqrt((n*sum_xx-sum_x*sum_x)*(n*sum_yy-sum_y*sum_y)),2);return lr}function LRpredict(modelObj,x){if(!modelObj)return null;if(!modelObj.slope||!modelObj.intercept)return null;if(isNaN(modelObj.slope)||isNaN(modelObj.intercept))return null;return parseFloat(modelObj.slope)*x+parseFloat(modelObj.intercept)}function LRpredictInverse(modelObj,y){if(!modelObj)return null;if(!modelObj.slope||!modelObj.intercept)return null;if(isNaN(modelObj.slope)||isNaN(modelObj.intercept))return null;if(parseFloat(modelObj.slope)===0)return null;return(parseFloat(y)-parseFloat(modelObj.intercept))/parseFloat(modelObj.slope)}function calculateMAE(predictions,actualValues){let sum=0;for(let i=0,l=predictions?.length;i<l;i++){sum+=Math.abs(predictions[i]-actualValues[i])}return Math.abs(sum/predictions?.length)||null}function isJsonObject(obj){return Object.prototype.toString.call(obj)==="[object Object]"}async function IDBinit(){return await new Promise(resolve=>{let request=indexedDB.open("Kanshi.Anime.Recommendations.Anilist.W~uPtWCq=vG$TR:Zl^#t<vdS]I~N70",1);request.onerror=error=>{console.error(error)};request.onsuccess=event=>{db=event.target.result;return resolve()};request.onupgradeneeded=event=>{db=event.target.result;db.createObjectStore("MyObjectStore");let transaction=event.target.transaction;transaction.oncomplete=()=>{return resolve()}}})}async function saveJSON(data,name){return await new Promise(async(resolve,reject)=>{try{let write=db.transaction("MyObjectStore","readwrite").objectStore("MyObjectStore").openCursor();write.onsuccess=async event=>{let put=await db.transaction("MyObjectStore","readwrite").objectStore("MyObjectStore").put(data,name);put.onsuccess=event=>{return resolve()};put.onerror=event=>{return resolve()}};write.onerror=async error=>{console.error(error);return reject()}}catch(ex){console.error(ex)}})}async function retrieveJSON(name){return await new Promise(resolve=>{try{let read=db.transaction("MyObjectStore","readwrite").objectStore("MyObjectStore").get(name);read.onsuccess=()=>{return resolve(read.result)};read.onerror=error=>{console.error(error);return resolve()}}catch(ex){console.error(ex);return resolve()}})}function getJapaneseStartDate({season,year,month,day}){if(parseInt(year)>=0){if(parseInt(month)>=0){return new Date(parseInt(year),parseInt(month),parseInt(day||1)||1)}const seasonKey=season?.trim()?.toLowerCase?.();if(["winter","spring","summer","fall"].includes(seasonKey)&&!isNaN(year)){let seasons={winter:new Date(parseInt(year),0,1),spring:new Date(parseInt(year),3,1),summer:new Date(parseInt(year),6,1),fall:new Date(parseInt(year),9,1)};return seasons[seasonKey]}return new Date(parseInt(year),0,1)}else{return null}}function ncsCompare(str1,str2){try{if(typeof str1!=="string"||typeof str2!=="string"){return false}return str1.trim().toLowerCase()===str2.trim().toLowerCase()}catch(e){}}let startPost=performance.now();function loadProgress(progress){let endPost=performance.now();if(endPost-startPost>17){self.postMessage({progress:progress});startPost=endPost}}
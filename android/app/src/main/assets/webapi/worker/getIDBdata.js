const entriesVersion=3;let db;self.addEventListener("unhandledrejection",event=>{console.error(event?.reason);self.postMessage({"Failed to retrieve the data":event?.reason||"Failed to retrieve the data"})});self.onmessage=async({data})=>{try{if(!db)await IDBinit();if(data.name==="animeEntriesIsEmpty"){self.postMessage(jsonIsEmpty(await retrieveJSON("animeEntries"))||entriesVersion>(await retrieveJSON("entriesVersion")??0))}else if(data.name==="username"){const userData=await retrieveJSON("userData");self.postMessage((userData?.username??await retrieveJSON("username"))||"")}else if(data.name==="recommendedAnimeListIsEmpty"){self.postMessage(jsonIsEmpty(await retrieveJSON("recommendedAnimeList")))}else if(data.name==="aniIdsNotificationToBeUpdated"){let updatedAniIdsNotification={};let aniIdsNotificationToBeUpdated=data?.aniIdsNotificationToBeUpdated;if(aniIdsNotificationToBeUpdated instanceof Array&&aniIdsNotificationToBeUpdated.length>0){let recommendedAnimeList=await retrieveJSON("recommendedAnimeList");if(recommendedAnimeList){updatedAniIdsNotification=aniIdsNotificationToBeUpdated.reduce((result,animeId)=>{let anime=recommendedAnimeList?.[animeId];if(anime){let title=anime?.title?.english||anime?.title?.userPreferred||anime?.title?.romaji||anime?.title?.native;let episodes=anime?.episodes;let animeUrl=anime?.animeUrl;let userStatus=anime?.userStatus?.toUpperCase?.();let episodeProgress=anime?.episodeProgress||0;result[anime.id]={title:typeof title==="string"?title:"",maxEpisode:typeof episodes==="number"?episodes:-1,animeUrl:typeof animeUrl==="string"?animeUrl:"",userStatus:typeof userStatus==="string"?userStatus:"UNWATCHED",episodeProgress:typeof episodeProgress==="number"?episodeProgress:0}}return result},{})}}self.postMessage(updatedAniIdsNotification)}else if(data.name){self.postMessage(await retrieveJSON(data.name))}}catch(error){console.error(error||"Failed to retrieve the data");self.postMessage({"Failed to retrieve the data":error||"Failed to retrieve the data"})}};async function IDBinit(){return await new Promise(resolve=>{let request=indexedDB.open("Kanshi.Anime.Recommendations.Anilist.W~uPtWCq=vG$TR:Zl^#t<vdS]I~N70",1);request.onerror=error=>{console.error(error)};request.onsuccess=event=>{db=event.target.result;return resolve()};request.onupgradeneeded=event=>{db=event.target.result;db.createObjectStore("MyObjectStore");let transaction=event.target.transaction;transaction.oncomplete=()=>{return resolve()}}})}async function retrieveJSON(name){return await new Promise((resolve,reject)=>{try{let read=db.transaction("MyObjectStore","readwrite").objectStore("MyObjectStore").get(name);read.onsuccess=()=>{return resolve(read.result)};read.onerror=error=>{console.error(error);return reject(error)}}catch(ex){console.error(ex);return reject(ex)}})}function jsonIsEmpty(obj){for(const key in obj){return false}return true}